# فصل ۷ پیچیدگی

وقتی به‌عنوان یک برنامه‌نویس حرفه‌ای کار می‌کنید، احتمالاً شخصی را می‌شناسید (یا خودتان این فرد هستید!) که این داستان ترسناک توسعه رایج را تجربه کرده: 
"ما پنج سال پیش شروع به کار روی این پروژه کردیم و فناوری‌ای که استفاده می‌کردیم/می‌ساختیم آن زمان مدرن بود، اما حالا قدیمی شده است. 
با وجود این فناوری منسوخ، روزبه‌روز همه چیز پیچیده‌تر می‌شود، و در نتیجه احتمال اتمام پروژه کمتر و کمتر می‌شود. 
اما اگر بازنویسی کنیم، ممکن است پنج سال دیگر هم همین‌جا باشیم!"

یکی دیگر از داستان‌های رایج این است: 
"ما نمی‌توانیم به‌اندازه کافی سریع توسعه دهیم تا با نیازهای مدرن کاربران همراه شویم." 
یا، "در حالی که ما در حال توسعه بودیم، شرکت X محصولی بهتر از ما نوشت و خیلی سریع‌تر از ما عمل کرد."

حالا می‌دانیم که منبع این مشکلات پیچیدگی است. 
شما با یک پروژه ساده شروع می‌کنید که می‌تواند در یک ماه تکمیل شود. 
سپس پیچیدگی اضافه می‌کنید و وظیفه سه ماه طول می‌کشد. 
سپس هر بخش را پیچیده‌تر می‌کنید و وظیفه نه ماه طول می‌کشد.

پیچیدگی روی پیچیدگی ساخته می‌شود—این فقط یک مسئله خطی نیست. 
یعنی نمی‌توانید فرض کنید: 
"ما ۱۰ ویژگی داریم، بنابراین اضافه کردن یک ویژگی دیگر فقط ۱۰ درصد زمان بیشتری می‌برد." 
در واقع، آن یک ویژگی جدید باید با تمام ۱۰ ویژگی موجود شما هماهنگ شود. 
پس، اگر ۱۰ ساعت زمان برنامه‌نویسی برای پیاده‌سازی خود ویژگی نیاز باشد، ممکن است ۱۰ ساعت دیگر برای هماهنگ کردن ۱۰ ویژگی موجود با ویژگی جدید نیاز باشد. 
هرچه ویژگی‌های بیشتری وجود داشته باشد، هزینه اضافه کردن یک ویژگی بیشتر می‌شود. 
می‌توانید این مشکل را با داشتن یک طراحی نرم‌افزاری عالی به حداقل برسانید، اما همیشه مقداری هزینه اضافی برای هر ویژگی جدید وجود خواهد داشت.

برخی پروژه‌ها با مجموعه‌ای از الزامات پیچیده شروع می‌شوند، آنچنان پیچیده که هرگز نسخه اول خود را منتشر نمی‌کنند. 
اگر در این وضعیت هستید، باید ویژگی‌ها را کاهش دهید. 
در اولین نسخه به دنبال فتح ماه نروید—چیزی که کار می‌کند را منتشر کنید و به‌مرور بهترش کنید.

بغیر از اضافه کردن ویژگی‌ها، موارد دیگری نیز وجود دارد که به پروژه شما پیچیدگی اضافه می‌کند. 
رایج‌ترین آن‌ها عبارت‌اند از:

_گسترش هدف نرم‌افزار_

به‌طور کلی، هرگز این کار را نکنید. 
ممکن است بخش بازاریابی شما رویای ساخت نرم‌افزاری را در سر داشته باشد که هم مالیات شما را انجام دهد و هم شام بپزد، اما شما باید با صدای بلند اعتراض کنید هر وقت پیشنهادی مثل این به سمت میزتان بیاید. 
به هدف فعلی نرم‌افزار خود پایبند باشید—فقط باید کاری که انجام می‌دهد را به‌خوبی انجام دهد و موفق خواهید شد (به شرط اینکه نرم‌افزار شما به مردم در چیزی که واقعاً به آن نیاز دارند و می‌خواهند کمک کند).

_اضافه کردن برنامه‌نویسان_

بله، درست است—اضافه کردن افراد بیشتر به تیم کار را ساده‌تر نمی‌کند؛ بلکه پیچیدگی اضافه می‌کند. 
یک کتاب معروف به نام The Mythical Man Month اثر فرد بروکس به این موضوع اشاره می‌کند. 
اگر ۱۰ برنامه‌نویس دارید، اضافه کردن یک نفر یازدهم به معنای صرف وقت برای هماهنگ کردن آن یک برنامه‌نویس با تیم است، به‌علاوه زمان برای هماهنگ کردن ۱۰ برنامه‌نویس فعلی با فرد جدید، و زمانی که فرد جدید برای تعامل با برنامه‌نویسان فعلی صرف می‌کند، و همین‌طور ادامه پیدا می‌کند. 
احتمال موفقیت با یک گروه کوچک از برنامه‌نویسان خبره بیشتر است تا یک گروه بزرگ از برنامه‌نویسان غیرماهر.

_تغییر چیزهایی که نیازی به تغییر ندارند_

هر زمانی که چیزی را تغییر می‌دهید، پیچیدگی اضافه می‌کنید. 
چه این تغییر در یک نیازمندی باشد، یا یک طراحی، یا فقط یک قطعه کد باشد، این کار امکان بروز باگ‌های جدید را فراهم می‌کند. 
به‌علاوه زمانی که برای تصمیم‌گیری در مورد تغییر صرف می‌شود، زمانی که برای پیاده‌سازی تغییر نیاز است، زمانی که برای هماهنگ کردن این تغییر با تمام قطعات دیگر نرم‌افزار نیاز است، و زمانی که برای رفع ایرادهای تغییر صرف می‌شود، و همچنین زمانی که برای سایر تست‌های تغییر نیاز است. 
هر تغییر به لحاظ تمام این پیچیدگی‌ها روی تغییر قبلی ساخته می‌شود، بنابراین هرچه بیشتر تغییر دهید، زمان بیشتری برای هر تغییر جدید لازم خواهد بود. 
البته هنوز هم انجام برخی تغییرات مهم است، اما باید تصمیمات آگاهانه‌ای در مورد آن‌ها بگیرید، نه اینکه فقط بر اساس هوی و هوس تغییر دهید.

_گیر افتادن در تکنولوژی‌های بد_

در واقع، این زمانی است که شما تصمیم به استفاده از یک تکنولوژی می‌گیرید و سپس برای مدت طولانی با آن گیر می‌افتید، زیرا به آن وابسته شده‌اید. 
در این معنا، یک تکنولوژی "بد" است اگر شما را قفل کند (اجازه ندهد به‌راحتی به یک تکنولوژی دیگر در آینده تغییر دهید)، برای نیازهای آینده شما انعطاف‌پذیر نباشد، یا فقط کیفیت کافی برای طراحی نرم‌افزار ساده با آن را نداشته باشد.

_کژفهمی_

برنامه‌نویسانی که به‌طور کامل کار خود را نمی‌فهمند، تمایل به توسعه سیستم‌های پیچیده دارند. 
این می‌تواند به یک چرخه معیوب تبدیل شود: 
کژفهمی منجر به پیچیدگی می‌شود، که منجر به کژفهمی‌های بیشتر می‌شود، و غیره. 
یکی از بهترین راه‌ها برای بهبود مهارت‌های طراحی خود این است که مطمئن شوید سیستم‌ها و ابزارهایی که با آن‌ها کار می‌کنید را به‌طور کامل می‌فهمید. 
هرچه بیشتر آن‌ها را بفهمید و هرچه بیشتر در مورد نرم‌افزار به‌طور کلی بدانید، طراحی‌های شما ساده‌تر خواهند بود.

_طراحی ضعیف یا بدون طراحی_

به‌طور کلی، طراحی ضعیف یا عدم داشتن طراحی به معنای "شکست در برنامه‌ریزی برای تغییر" است. 
به یاد داشته باشید که چیزها تغییر خواهند کرد، و داشتن طراحی برای حفظ سادگی هنگام رشد پروژه ضروری است. 
شما باید از ابتدا به‌خوبی طراحی کنید و با گسترش سیستم همچنان به خوب طراحی کردن ادامه دهید—در غیر این صورت، می‌توانید به‌سرعت پیچیدگی عظیمی را معرفی کنید، زیرا با یک طراحی ضعیف، هر ویژگی جدید پیچیدگی کد را چند برابر می‌کند، به‌جای اینکه فقط کمی به آن اضافه کند.

_اختراع دوباره چرخ_

اگر شما سعی کنید ،برای مثال، یک یک نیازتان، پروتکلی اختراع کنید درحالی‌که یک پروتکل کاملاً خوب برای آن وجود دارد، زمان زیادی را صرف کار روی پروتکل خواهید کرد، درحالی‌که می‌توانستید روی نرم‌افزار خود کار کنید. 
تقریباً هیچ‌گاه نباید وابستگی بزرگی مانند یک سرور وب، پروتکل یا کتابخانه اصلی را از ابتدا اختراع کنید، مگر اینکه محصول شما باشد. 
تنها زمانی اختراع دوباره چرخ مجاز است که یکی از موارد زیر صادق باشد:

  1. شما به چیزی نیاز دارید که هنوز وجود ندارد.
  2. تمام "چرخ"های موجود تکنولوژی‌های بدی هستند که شما را قفل می‌کنند.
  3. "چرخ"های موجود به‌طور اساسی قادر به رفع نیازهای شما نیستند.
  4. "چرخ"های موجود به‌درستی نگهداری نمی‌شوند و شما نمی‌توانید نگهداری آن‌ها را به عهده بگیرید (زیرا، برای مثال، شما به کد منبع دسترسی ندارید).
- 
همه این عوامل به‌آرامی و به‌تدریج به پروژه شما آسیب می‌رسانند، نه به‌طور آنی.
بیشتر آن‌ها فقط آسیب بلندمدت وارد می‌کنند—چیزی که تا یک سال یا بیشتر نخواهید دید—بنابراین وقتی کسی آن‌ها را پیشنهاد می‌دهد، اغلب بی‌ضرر به‌نظر می‌رسند.
و حتی وقتی شروع به اجرای آن‌ها می‌کنید، ممکن است خوب به‌نظر برسند.
اما با گذشت زمان—و به‌ویژه با انباشته شدن بیشتر و بیشتر آن‌ها—پیچیدگی آشکارتر می‌شود و رشد می‌کند و رشد می‌کند و رشد می‌کند، تا زمانی که قربانی دیگری از آن داستان ترسناک رایج یعنی محصولی که هرگز منتشر نمی‌شود شوید.

## پیچیدگی و هدف

هدف اساسی هر سیستمی که روی آن کار می‌کنید باید کاملاً ساده باشد. 
این کمک می‌کند که سیستم به‌طور کلی به ساده‌ترین شکل ممکن باقی بماند. اما اگر شروع به اضافه کردن ویژگی‌هایی کنید که هدف دیگری را دنبال می‌کنند، همه چیز به‌سرعت بسیار پیچیده می‌شود. 
برای مثال، هدف اساسی یک ویرایشگر متن این است که به شما کمک کند چیزی بنویسید. 
اگر ناگهان آن را به‌گونه‌ای تغییر دهید که بتواند ایمیل‌های شما را نیز بخواند، سیستم به‌طور مضحکی پیچیده می‌شود. 
آیا می‌توانید تصور کنید رابط کاربری آن چگونه به نظر می‌رسد؟ 
دکمه‌ها را کجا قرار می‌دهید؟ 
ما می‌گوییم که این یک نقض در هدف ویرایشگر متن شماست. 
شما حتی هدف آن را گسترش ندادید؛ فقط ویژگی‌هایی اضافه کردید که هیچ ارتباطی با آن ندارند.

همچنین مهم است که به هدف کاربر نیز فکر کنید. 
کاربر شما در حال تلاش برای انجام کاری است. 
ایده‌آل این است که هدف برنامه شما بسیار نزدیک (در کلماتی که برای توصیف آن استفاده می‌کنید) به هدف کاربر باشد. 
برای مثال، فرض کنید هدف کاربر این است که مالیات‌های خود را انجام دهد. 
او به نرم‌افزاری نیاز دارد که هدف آن کمک به افراد برای انجام مالیات‌هایشان باشد.

اگر هدف شما و هدف کاربر همخوانی نداشته باشند، احتمالاً زندگی او را دشوار می‌کنید. 
برای مثال، اگر او بخواهد ایمیل‌های خود را بخواند، اما هدف اصلی برنامه‌ای که استفاده می‌کند نمایش تبلیغات به کاربران باشد، آن اهداف با هم همخوانی ندارند. 
می‌خواهید ببینید کاربر شما چقدر سریع عصبانی می‌شود؟ 
انجام کار او را دشوار کنید. 
پنجره‌های پاپ‌آپ را جلوی او باز کنید وقتی که در حال انجام کاری است. 
آن‌قدر ویژگی به برنامه‌تان اضافه کنید که نتواند ویژگی درست را پیدا کند. 
از تعداد زیادی آیکون عجیب استفاده کنید که او نمی‌فهمد. 
راه‌های زیادی برای این کار وجود دارد، اما همه آن‌ها به یک نکته برمی‌گردند: 
مداخله در هدف کاربر یا نقض هدف اساسی خود برنامه.

گاهی اوقات، بازاریابان یا مدیران اهدافی برای یک برنامه دارند که واقعاً با هدف اساسی برنامه همسو نیست، مانند "جذاب بودن"، "داشتن طراحی مدرن"، "محبوب شدن در رسانه‌های خبری"، "استفاده از آخرین تکنولوژی‌ها" و غیره. 
این افراد ممکن است برای سازمان شما مهم باشند، اما آن‌ها نباید تصمیم‌گیرندگان درباره آنچه برنامه شما انجام می‌دهد باشند! 
به‌عنوان یک طراح نرم‌افزار یا مدیر فنی، این وظیفه شماست که اطمینان حاصل کنید برنامه در مسیر خود باقی می‌ماند و هرگز هدف اساسی آن را نقض نمی‌کند. 
هیچ‌کس دیگر این مسئولیت را بر عهده نخواهد گرفت. 
گاهی ممکن است واقعاً مجبور شوید برای آن بجنگید، اما در بلندمدت ارزشش را خواهد داشت.

و این‌طور نیست که با این فلسفه به یک شکست بازاریابی برسید. 
محصولات زیادی وجود دارند که با پایبندی به یک هدف ساده بسیار موفق بوده‌اند. 
هدف صابون فقط تمیز کردن چیزهاست. 
نمک فقط غذاها را شور می‌کند. 
یک لامپ فقط محیط را روشن می‌کند. 
اما همه این‌ها محصولاتی هستند که دهه‌هاست از شرکت‌های بزرگ پشتیبانی کرده‌اند. 
نیازی نیست محصولی پیچیده داشته باشید تا بازاریابی مؤثری داشته باشید—شما فقط باید در بازاریابی دانش و مهارت داشته باشید، که یک حوزه کاملاً جدا از طراحی نرم‌افزار است.

در واقع، نیازی به پیچیده و فانتزی کردن کارها و تلاش برای انجام ۵۰۰ کار در یک برنامه نیست. 
کاربران با یک محصول متمرکز و ساده که هرگز هدف اساسی خود را نقض نمی‌کند، خوشحال‌تر هستند.

## تکنولوژی‌های بد

یکی دیگر از منابع رایج پیچیدگی، انتخاب تکنولوژی اشتباه برای استفاده در سیستم شما است—به‌ویژه تکنولوژی‌ای که در نهایت با نیازهای آینده همخوانی ندارد. 
با این حال، بدون توانایی پیش‌بینی آینده، ممکن است تشخیص اینکه چه تکنولوژی را باید اکنون انتخاب کنید، دشوار باشد. 
خوشبختانه، سه عامل وجود دارد که می‌توانید به آن‌ها نگاه کنید تا تعیین کنید آیا یک تکنولوژی "بد" است یا نه، قبل از اینکه حتی شروع به استفاده از آن کنید: 
پتانسیل بقا، تعامل‌پذیری و توجه به کیفیت.

### پتانسیل بقا

پتانسیل بقا یعنی اینکه چقدر احتمال دارد این تکنولوژی همچنان در آینده نگهداری شود. 
اگر با یک کتابخانه یا هر وابستگی دیگری مواجه شوید که منسوخ شده است، و دیگر نگهداری نمی‌شود، واقعاً دچار مشکل خواهید شد.

می‌توانید با نگاه کردن به تاریخچه انتشار اخیر یک قطعه نرم‌افزار، ایده‌ای از پتانسیل بقای آن به دست آورید. 
آیا توسعه‌دهندگان مرتباً نسخه‌های جدیدی را منتشر کرده‌اند که مشکلات واقعی کاربران را حل کند؟ 
همچنین، توسعه‌دهندگان چقدر به گزارش‌های باگ پاسخگو هستند؟ 
آیا mailing list یا تیم پشتیبانی فعالی دارند؟ 
آیا افراد زیادی آنلاین در مورد این تکنولوژی صحبت می‌کنند؟ 
اگر یک تکنولوژی اکنون حرکت زیادی دارد، می‌توانید نسبتاً مطمئن باشید که به این زودی‌ها نخواهد مرد.

همچنین بررسی کنید که آیا فقط یک فروشنده در حال تبلیغ این تکنولوژی است، یا اینکه به‌طور گسترده در مناطق مختلف نرم‌افزار توسط توسعه‌دهندگان مختلف پذیرفته و استفاده شده است. 
اگر فقط یک فروشنده باشد که سیستم را تبلیغ و پیش می‌برد، این خطر وجود دارد که آن فروشنده یا از کار بیفتد یا تصمیم بگیرد که دیگر سیستم را نگهداری نکند.

> [!NOTE]
> **محبوبیت**
> ممکن است به‌نظر برسد که ما می‌گوییم شما باید فقط محبوب‌ترین تکنولوژی‌ای که نیازهای شما را برآورده می‌کند انتخاب کنید.
> تا حدی، این درست است—تکنولوژی‌های محبوب پتانسیل بقای زیادی دارند.
> با این حال، باید به تفاوت بین ابزارهایی که به‌طور معتبر محبوب هستند و ابزارهایی که فقط به این دلیل محبوب هستند که نوعی انحصار دارند، توجه کنید.
> 
> در زمان نوشتن این کتاب، C یکی از زبان‌های برنامه‌نویسی معتبر محبوب است.
> افراد زیادی از آن در سازمان‌های مختلف برای اهداف مختلف استفاده می‌کنند.
> این زبان موضوع چندین استاندارد بین‌المللی است و چندین پیاده‌سازی از آن استانداردها وجود دارد، از جمله چندین کامپایلر که به‌طور گسترده استفاده می‌شوند.
> 
> با این حال[^1]، برخی تکنولوژی‌ها فقط به این دلیل محبوب هستند که مجبور به استفاده از آن‌ها هستید.
> فرض کنید شرکت X زبان برنامه‌نویسی خاص خود را طراحی می‌کند.
> سپس دستگاه محبوبی طراحی می‌کند که فقط برنامه‌های نوشته‌شده به آن زبان را می‌پذیرد.
> این مورد همان حالت "یک فروشنده" است که در متن ذکر شده—ممکن است زبان محبوب به‌نظر برسد، اما در واقع پتانسیل بقای ضعیفی دارد مگر اینکه به‌طور گسترده در صنعت نرم‌افزار پذیرفته شود.

### تعامل‌پذیری

تعامل‌پذیری معیاری از این است که اگر مجبور شوید، چقدر راحت می‌توانید یک تکنولوژی را کنار بگذارید. 
برای به‌دست آوردن ارزیابی‌ای از تعامل‌پذیری یک تکنولوژی، از خود بپرسید: 
"آیا می‌توانیم به روشی استاندارد با این تکنولوژی تعامل داشته باشیم، به‌طوری که اگر نیاز به تغییر به سیستم دیگری باشد، سراغ سیستم هایی برویم که از همان استاندارد پیروی می‌کند؟"

برای مثال، استانداردهای بین‌المللی برای نحوه تعامل یک برنامه با یک سیستم پایگاه داده وجود دارد. 
برخی از سیستم‌های پایگاه داده این استانداردها را به‌خوبی پشتیبانی می‌کنند. 
اگر یکی از این سیستم‌های پایگاه داده خوب را انتخاب کنید، می‌توانید در آینده با تغییرات جزئی به سیستم پایگاه داده دیگری منتقل شوید.

با این حال، برخی دیگر از سیستم‌های پایگاه داده در پشتیبانی از استانداردها خوب نیستند. 
اگر بخواهید بین سیستم‌های پایگاه داده که از استانداردها پشتیبانی نمی‌کنند، جابه‌جا شوید، باید برنامه خود را بازنویسی کنید. 
بنابراین، وقتی یکی از این سیستم‌های غیراستاندارد را انتخاب می‌کنید، در آن قفل می‌شوید و نمی‌توانید به‌راحتی به سیستم دیگری تغییر دهید.

### توجه به کیفیت

این مورد بیشتر یک اندازه‌گیری ذهنی است، اما ایده این است که ببینید آیا محصول در نسخه‌های اخیر خود بهبود یافته است یا خیر. 
اگر می‌توانید کد منبع را ببینید، بررسی کنید که آیا توسعه‌دهندگان در حال بازسازی و پاکسازی کد هستند. آیا استفاده از آن ساده‌تر شده است یا پیچیده‌تر؟ 
آیا افرادی که تکنولوژی را نگهداری می‌کنند واقعاً به کیفیت محصول خود اهمیت می‌دهند؟ 
آیا اخیراً مشکلات امنیتی جدی زیادی در نرم‌افزار وجود داشته که به‌نظر می‌رسد ناشی از برنامه‌نویسی ضعیف بوده باشد؟

### دلایل دیگر

هنگام انتخاب یک فناوری، جنبه‌های دیگری نیز وجود دارد که باید در نظر بگیرید—در درجه اول سادگی آن و اینکه چقدر برای اهداف شما مناسب است. 
نظر شخصی نیز می‌تواند نقش داشته باشد، اما پس از اینکه تمام ملاحظات عملی را در نظر گرفتید. 
برخی افراد ظاهر یک زبان برنامه‌نویسی را بیشتر از سایر زبان‌ها دوست دارند. 
این می‌تواند گاهی اوقات دلیل معتبری برای انتخاب یک فناوری باشد—اگر شما یک فناوری‌ای را از دیگر فناوری‌ها بیشتر دوست دارید و همه چیزهای دیگر بین آنها برابر است، با آن فناوری که شما را بیشتر خوشحال می‌کند، پیش بروید. 
به هر حال، شما کسی هستید که قرار است از آن استفاده کنید—نظر شما مهم است! دستورالعمل‌های بالا به شما کمک می‌کند تا انتخاب‌های بد را حذف کنید؛ بقیه به تحقیق شخصی، نیازها و خواسته‌های شما بستگی دارد.

## پیچیدگی و راه‌حل اشتباه

اغلب، اگر چیزی بسیار پیچیده می‌شود، به این معنی است که در طراحی، جایی در سطحی پایین‌تر از جایی که پیچیدگی ظاهر می‌شود، خطایی وجود دارد.

برای مثال، بسیار دشوار است که یک ماشین با چرخ‌های مربع به‌سرعت حرکت کند. 
تنظیم موتور مشکل را حل نمی‌کند—شما باید طراحی ماشین را دوباره انجام دهید تا چرخ‌های آن گرد شوند.

هر زمانی که در برنامه خود با پیچیدگی غیرقابل‌حل مواجه می‌شوید، به این دلیل است که مشکلی اساسی در طراحی وجود دارد. 
اگر مشکل در یک سطح غیرقابل‌حل به نظر می‌رسد، به عقب برگردید و ببینید که چه چیزی ممکن است در پایه مشکل باشد.

برنامه‌نویسان در واقع اغلب این کار را انجام می‌دهند. 
ممکن است با خودتان بگویید، "کد من بسیار نامرتب است و اضافه کردن یک ویژگی جدید بسیار پیچیده است!" 
خوب، مشکل اساسی شما این است که کد نامرتب است. 
آن را تمیز کنید، کد موجود را ساده کنید و خواهید دید که اضافه کردن ویژگی جدید نیز ساده خواهد شد.

### چه مشکلی را می‌خواهید حل کنید؟

اگر کسی به سراغ شما بیاید و چیزی مثل این بگوید: 
"چگونه می‌توانم این اسب را به ماه پرواز دهم؟" 
سوالی که باید بپرسید این است: 
"چه مشکلی را می‌خواهید حل کنید؟" 
ممکن است متوجه شوید که آنچه این شخص واقعاً نیاز دارد جمع‌آوری تعدادی سنگ خاکستری است. 
چرا او فکر می‌کرد که باید به ماه پرواز کند و از اسب برای این کار استفاده کند، فقط خودش می‌داند. 
مردم به این شکل دچار سردرگمی می‌شوند. 
از آن‌ها بپرسید که چه مشکلی را می‌خواهند حل کنند و یک راه‌حل ساده شروع به آشکار شدن می‌کند. 
برای مثال، در این مورد، وقتی مشکل را به‌طور کامل درک کنیم، راه‌حل ساده و واضح می‌شود: 
او باید فقط بیرون برود و تعدادی سنگ خاکستری پیدا کند—بدون نیاز به اسب.

بنابراین، وقتی اوضاع پیچیده می‌شود، به عقب برگردید و نگاهی به مشکلی که می‌خواهید حل کنید بیندازید. 
یک گام بزرگ به عقب بردارید. 
شما مجاز به زیر سوال بردن همه چیز هستید. 
شاید زمانی فکر می‌کردید که تنها راه برای رسیدن به عدد چهار، جمع دو و دو است و هرگز به اضافه کردن یک و سه فکر نکردید، یا اصلا صرف‌نظر کردن از جمع زدن و فقط قرار دادن چهار. 
مشکل این است که "چگونه می‌توانم عدد چهار را به دست بیاورم؟" 
هر روشی برای حل این مشکل قابل‌قبول است، پس آنچه باید انجام دهید این است که بفهمید بهترین روش برای موقعیتی که در آن هستید چیست.

فرضیات خود را کنار بگذارید. 
واقعاً به مشکلی که می‌خواهید حل کنید نگاه کنید. 
مطمئن شوید که همه جنبه‌های آن را به‌طور کامل درک کرده‌اید، سپس ساده‌ترین راه‌حل را پیدا کنید. 
از خود نپرسید، "چگونه این مشکل را با استفاده از کد فعلی خود حل کنم؟" 
یا "فلان پروفسور چگونه این مشکل را در برنامه خود حل کرد؟" 
نه—فقط از خود بپرسید، "چگونه، به‌طور کلی، در یک دنیای کامل، باید این نوع مشکل حل شود؟" 
از آنجا ممکن است متوجه شوید که کد شما چگونه باید دوباره کار شود. 
سپس می‌توانید کد خود را دوباره‌نویسی کنید. 
سپس می‌توانید مشکل را حل کنید.

## مشکلات پیچیده

گاهی اوقات از شما خواسته می‌شود تا مشکلی را حل کنید که ذاتاً بسیار پیچیده است—برای مثال، بررسی املا (spell checking) یا ساختن کامپیوتری که شطرنج بازی کند. 
این بدان معنا نیست که راه‌حل شما باید پیچیده باشد، اما به این معناست که هنگام برخورد با این مشکل، باید بیشتر از معمول تلاش کنید تا کد خود را ساده نگه دارید.

اگر با مشکلی پیچیده مواجه هستید، آن را به‌صورت زبانی ساده روی کاغذ بنویسید یا آن را به‌صورت یک نمودار ترسیم کنید. 
واقعاً برخی از بهترین برنامه‌نویسی‌ها روی کاغذ انجام می‌شوند. 
قرار دادن آن در کامپیوتر فقط یک جزئیات کوچک است.

**بسیاری از مشکلات دشوار طراحی را می‌توان به‌سادگی با رسم یا نوشتن آن‌ها روی کاغذ حل کرد.**

## مدیریت پیچیدگی

به‌عنوان یک برنامه‌نویس، شما با پیچیدگی مواجه خواهید شد. 
برنامه‌نویسان دیگر برنامه‌های پیچیده‌ای خواهند نوشت که شما باید آن‌ها را اصلاح کنید. 
طراحان سخت‌افزار و طراحان زبان زندگی شما را دشوار خواهند کرد.

اگر بخشی از سیستم شما بیش‌ازحد پیچیده است، راه مشخصی برای رفع آن وجود دارد—باز طراحی تک‌تک قطعات، در گام‌های کوچک. 
هر اصلاح باید تا حد ممکن کوچک باشد تا بدون افزودن پیچیدگی بیشتر انجام شود. 
بزرگ‌ترین خطر هنگام انجام این فرایند این است که ممکن است پیچیدگی بیشتری را با اصلاحات خود معرفی کنید. 
به همین دلیل است که بسیاری از بازطراحی‌ها یا بازنویسی‌ها در نهایت شکست می‌خورند—آن‌ها پیچیدگی بیشتری از آنچه که اصلاح می‌کنند معرفی می‌کنند، یا به همان اندازه پیچیده باقی می‌مانند.

هر گام می‌تواند به‌اندازه دادن یک نام بهتر به یک متغیر باشد، یا فقط اضافه کردن چند توضیح به کد گیج‌کننده. 
اما اغلب، این گام‌ها شامل تقسیم یک قطعه پیچیده به چندین قطعه ساده است.

برای مثال، اگر یک فایل طولانی دارید که تمام کد شما را در بر دارد، شروع به بهبود آن با جدا کردن یک قطعه کوچک به یک فایل جداگانه کنید. 
سپس طراحی آن قطعه کوچک را بهبود دهید. 
سپس قطعه دیگری از سیستم را به یک فایل جدید جدا کنید و طراحی آن را بهبود دهید. 
به این ترتیب ادامه دهید و در نهایت به یک سیستم قابل‌اعتماد، قابل‌درک و قابل‌نگهداری خواهید رسید.

اگر سیستم شما بسیار پیچیده است، این کار ممکن است زمان زیادی ببرد، بنابراین باید شکیبا باشید. 
ابتدا باید سیستمی را تصور کنید که از سیستمی که اکنون دارید ساده‌تر است—حتی اگر فقط به‌صورت جزئی. 
سپس به‌صورت گام‌به‌گام به سمت آن سیستم ساده‌تر کار کنید. 
وقتی به آن سیستم ساده‌تر رسیدید، دوباره سیستمی حتی ساده‌تر را تصور کنید و به سمت آن کار کنید. 
شما هرگز مجبور نیستید سیستم "کامل" را تصور کنید، زیرا چنین سیستمی وجود ندارد. 
شما فقط باید به‌طور مداوم به سمت سیستمی بهتر از آنچه که دارید کار کنید و در نهایت به سطحی از سادگی با قابلیت مدیریت بالا خواهید رسید.

بااین‌حال، توجه به این نکته مهم است که نمی‌توانید نوشتن ویژگی‌ها را متوقف کنید و مدت طولانی را فقط صرف بازطراحی کنید. 
قانون تغییر به ما می‌گوید که محیط اطراف برنامه شما به‌طور مداوم در حال تغییر است و بنابراین عملکرد برنامه شما باید سازگار شود. 
اگر برای مدت طولانی از دیدگاه کاربر بهبود پیدا نکنید و سازگار نشوید، خطر از دست دادن کاربران خود و مرگ پروژه‌تان را به همراه خواهید داشت.

خوشبختانه، راه‌های مختلفی برای متعادل کردن این دو نیاز—نوشتن ویژگی‌ها و مدیریت پیچیدگی—وجود دارد. 
یکی از بهترین راه‌ها این است که بازطراحی خود را ابتدا با هدف ساده‌تر کردن پیاده‌سازی یک ویژگی خاص انجام دهید و سپس آن ویژگی را پیاده‌سازی کنید. 
به این ترتیب، به‌طور منظم بین کار بازطراحی و اضافه کردن ویژگی‌ها جابجا می‌شوید. 
این کار همچنین به شما کمک می‌کند که طراحی جدید شما با نیازهای واقعی شما به‌خوبی همخوانی داشته باشد، زیرا آن را با در نظر گرفتن یک کاربرد واقعی ایجاد می‌کنید. 
سیستم شما به‌تدریج پیچیدگی کمتری پیدا خواهد کرد و همچنان با نیازهای کاربران خود هماهنگ خواهید بود. 
حتی می‌توانید این کار را برای باگ‌ها نیز انجام دهید—اگر متوجه شوید که رفع این باگ در صورت وجود یک طراحی متفاوت آسان‌تر خواهد بود، ابتدا کد را بازطراحی کنید و سپس باگ را رفع کنید.

> [!NOTE]
> 
> **بازطراحی برای یک ویژگی**
> 
> پروژه‌ای به نام Bugzilla تمام داده‌های خود را در یک پایگاه داده ذخیره می‌کند.
> این پروژه به‌نحوی طراحی شده است که فقط از یک سیستم پایگاه داده خاص برای ذخیره داده‌ها پشتیبانی می‌کند که به آن OldDB گفته می‌شود.
> برخی مشتریان جدید می‌خواهند از یک سیستم پایگاه داده دیگر به نام NewDB برای ذخیره داده‌ها استفاده کنند.
> این مشتریان دلایل خوبی برای خواستن این ویژگی دارند:
> آن‌ها NewDB را بسیار بهتر از OldDB درک می‌کنند و از قبل NewDB را در شرکت‌های خود اجرا کرده‌اند.
> اما همه مشتریان فعلی می‌خواهند به استفاده از OldDB ادامه دهند.
> 
> بنابراین، Bugzilla باید شروع به پشتیبانی از بیش از یک پایگاه داده کند.
> این نیازمند تغییرات زیادی در کد است، زیرا Bugzilla هیچ کد متمرکزی برای ذخیره و دریافت اطلاعات از پایگاه داده ندارد.
> در عوض، دستورات پایگاه داده سفارشی زیادی در سراسر کد پخش شده‌اند که خاص OldDB هستند و روی NewDB کار نمی‌کنند.
> 
> یک گزینه این است که در تمام کد از دستورات if استفاده شود و برای هرجا که پایگاه داده دسترسی دارد، کدی متفاوت برای NewDB و OldDB نوشته شود.
> با این حال، این تقریباً پیچیدگی کل کد را دو برابر می‌کند، و تیم Bugzilla فقط از چند برنامه‌نویس پاره‌وقت تشکیل شده است.
> اگر پیچیدگی سیستم دو برابر شود، آن‌ها دیگر نمی‌توانند آن را نگهداری کنند.
> 
> در عوض، تیم Bugzilla تصمیم می‌گیرد سیستم را دوباره طراحی کند تا بتواند به‌راحتی از چندین پایگاه داده پشتیبانی کند.
> این پروژه‌ای عظیم است. در اینجا یک مرور کلی از نحوه انجام آن آورده شده است:
> 
> 1. برخی دستورات استاندارد پایگاه داده وجود دارند که روی هر سیستم پایگاه داده کار می‌کنند، اما در برخی جاهای پروژه دستورات استاندارد استفاده نشده است. 
> سیستم را بررسی کنید و هرجا که ممکن است از دستورات استاندارد استفاده کند.
> در هر مرحله فقط یک فایل را تغییر دهید.
> 2. برای دستورات پایگاه داده‌ای که نسخه استاندارد ندارند، توابعی ایجاد کنید که دستور صحیح برای پایگاه داده در حال استفاده را برگردانند.
> یک تابع برای یک دستور غیر استاندارد ایجاد می‌شود و سپس هر نمونه از آن دستور غیر استاندارد با فراخوانی تابع جایگزین می‌شود.
> این فرایند را ادامه دهید تا تمام دستورات غیر استاندارد حذف شوند.
> 3. بخش‌های زیادی از کد کاملاً بر اساس ویژگی‌هایی طراحی شده‌اند که فقط در OldDB وجود دارند.
> استفاده از این ویژگی‌های خاص OldDB را متوقف کنید و در عوض از ویژگی‌های استانداردی استفاده کنید که در تمام سیستم‌های پایگاه داده کار می‌کنند.
> این ویژگی‌ها را یکی یکی و در صورت لزوم در چندین مرحله رفع کنید.
> 4. سیستم نصب Bugzilla را دوباره طراحی کنید تا بتواند روی هر سیستم پایگاه داده نصب شود، نه فقط OldDB.
> این کار ابتدا شامل بازطراحی سیستم نصب و ساده‌تر کردن آن است و سپس تنظیم آن کد ساده‌شده برای پشتیبانی از هر دو OldDB و NewDB.
> 
> هر مرحله فوق یک پروژه مستقل است.
> همه آن‌ها به گام‌های کوچک‌تر تقسیم می‌شوند تا طراحی خوبی برای هر بخش از کار انجام شود.
> همچنین، سیستم پس از هر تغییری آزمایش می‌شود تا مطمئن شوند که همان‌طور که قبلاً روی OldDB کار می‌کرده، همچنان به همان شکل کار می‌کند.
> 
> آیا این به یک سیستم کامل منجر می‌شود؟ نه.
> اما به سیستمی منجر می‌شود که بهتر از قبل است—علاوه بر پشتیبانی از NewDB، اکنون کد بسیار آسان‌تر از قبل نگهداری می‌شود.
> در نهایت، Bugzilla گسترش یافت تا از چهار سیستم پایگاه داده مختلف پشتیبانی کند، همه به این دلیل که این کار پشتیبانی از سیستم‌های جدید را بسیار آسان‌تر کرد.[^2]

### ساده‌تر کردن یک قطعه

موارد ذکر شده همه خوب و قابل‌قبول هستند، اما در عمل چه کاری باید انجام دهید تا یک قطعه کد را ساده‌تر کنید؟ 
خب، اینجاست که تمام دانش طراحی نرم‌افزار موجود در جهان به کار می‌آید. 
مطالعه الگوهای طراحی، روش‌های مدیریت کد قدیمی و تمام ابزارهای مهندسی نرم‌افزار به‌طور کلی، کمک زیادی می‌کند. 
دانستن چندین زبان برنامه‌نویسی و آشنایی با کتابخانه‌های مختلف می‌تواند بسیار مفید باشد، زیرا هرکدام شامل روش‌های مختلفی برای فکر کردن به مشکلات هستند که می‌توانند برای موقعیت شما قابل‌استفاده باشند، حتی اگر از آن زبان‌ها یا کتابخانه‌ها استفاده نمی‌کنید.

مطالعه این مطالب گزینه‌های زیادی را در اختیار شما قرار می‌دهد تا زمانی که با پیچیدگی مواجه می‌شوید، از آن‌ها انتخاب کنید. 
قوانین طراحی نرم‌افزار به شما کمک می‌کنند تا بفهمید کدام گزینه‌ها مناسب هستند و سپس قضاوت و تجربه شما مشخص می‌کند که واقعاً با مشکل خاص خود چه باید کرد. 
هرگز به‌صورت ماشینی از یک ابزار استفاده نکنید فقط به این دلیل که یک مرجع آن را بهترین دانسته است—همیشه کاری را انجام دهید که برای کدی که به آن نگاه می‌کنید و موقعیتی که در آن هستید، مناسب است.

بااین‌حال، گاهی ممکن است به یک قطعه کد نگاه کنید و هیچ ابزاری برای ساده کردن آن نداشته باشید. 
یا ممکن است تازه‌کار باشید و زمان مطالعه تمام این اطلاعات را به‌طور فوری نداشته باشید. 
در این صورت، باید به پیچیدگی نگاه کنید و از خود بپرسید، "چگونه می‌توان این کد را ساده‌تر کرد یا آن را قابل‌فهم‌تر ساخت؟"

این سوال کلیدی پشت هر ساده‌سازی است. 
هر پاسخ درست به این سوال راهی معتبر برای ساده‌تر کردن کد شماست؛ ابزارها و تکنیک‌های طراحی نرم‌افزار فقط به ما کمک می‌کنند تا پاسخ‌های بهتری پیدا کنیم.

### پیچیدگی غیرقابل‌رفع

وقتی در حال ساده‌سازی سیستم خود هستید، ممکن است متوجه شوید که برخی پیچیدگی‌ها اجتناب‌ناپذیر هستند، مانند پیچیدگی سخت‌افزار پایه‌ای. 
اگر با چنین پیچیدگی غیرقابل‌رفعی روبرو شدید، هدف شما این است که پیچیدگی را مخفی کنید. 
برای آن یک واسط ساده ایجاد کنید که برای سایر برنامه‌نویسان قابل‌فهم و استفاده باشد.

## بازنویسی

برخی طراحان وقتی با سیستمی بسیار پیچیده روبرو می‌شوند، آن را کنار گذاشته و از ابتدا شروع می‌کنند. 
با این حال، بازنویسی یک سیستم از ابتدا، در واقع پذیرش شکست به‌عنوان یک طراح است. 
این بیان می‌کند: 
"ما نتوانستیم سیستمی قابل نگهداری طراحی کنیم و بنابراین باید از نو شروع کنیم."

برخی معتقدند که همه سیستم‌ها در نهایت باید بازنویسی شوند. 
این درست نیست. 
ممکن است سیستمی طراحی کنید که هرگز نیازی به دور انداختن نداشته باشد. 
یک طراح نرم‌افزار که می‌گوید "ما باید یک روز همه چیز را دور بریزیم" مانند یک معمار ساختمان است که می‌گوید "این آسمان‌خراش یک روز فرو خواهد ریخت." 
اگر آسمان‌خراش به‌درستی طراحی نشده و به‌خوبی نگهداری نشود، بله، روزی فرو خواهد ریخت. 
اما اگر از ابتدا به‌درستی ساخته شود و سپس به‌خوبی نگهداری شود، چرا باید فرو بریزد؟

ساختن سیستم‌های نرم‌افزاری قابل نگهداری به‌اندازه ساختن آسمان‌خراش‌های محکم ممکن است.

با این حال، گفته شد، مواقعی وجود دارد که بازنویسی قابل‌قبول است. 
اما این موارد بسیار نادر هستند. 
شما باید فقط در صورتی به بازنویسی اقدام کنید که همه موارد زیر صادق باشد:

1. شما تخمین دقیقی دارید که نشان می‌دهد بازنویسی سیستم استفاده بهتری از زمان است نسبت به بازطراحی سیستم موجود. 
فقط حدس نزنید—آزمایش‌های واقعی با بازطراحی سیستم فعلی انجام دهید تا ببینید چطور پیش می‌رود. 
ممکن است مقابله با پیچیدگی موجود و حل بخشی از آن بسیار سخت باشد، اما باید چند بار این کار را انجام دهید تا بدانید که رفع همه پیچیدگی چقدر تلاش نیاز دارد.
2. شما زمان زیادی برای ساختن یک سیستم جدید دارید.
3. شما طراح بهتری از طراح اصلی سیستم هستید یا اگر خودتان طراح اصلی هستید، مهارت‌های طراحی شما از زمان طراحی اولیه سیستم به‌طور چشمگیری بهبود یافته است.
4. شما کاملاً قصد دارید که این سیستم جدید را در یک سری مراحل ساده طراحی کنید و کاربرانی دارید که بتوانند در هر مرحله به شما بازخورد بدهند.
5. شما منابع کافی برای هم‌زمان نگهداری سیستم موجود و طراحی سیستم جدید را دارید. 
هرگز نگهداری یک سیستم که در حال استفاده است را متوقف نکنید تا برنامه‌نویسان بتوانند آن را بازنویسی کنند. 
سیستم‌ها همیشه باید در صورت استفاده نگهداری شوند. 
و به یاد داشته باشید که توجه شخصی شما نیز یک منبع است که باید در نظر گرفته شود—آیا در هر روز زمان کافی دارید تا هم‌زمان طراح هر دو سیستم جدید و قدیمی باشید، اگر قرار است روی هر دو کار کنید؟

   
اگر تمام نکات فوق صادق است، ممکن است در وضعیتی باشید که بازنویسی قابل‌قبول باشد. 
در غیر این صورت، کار درست این است که با پیچیدگی سیستم موجود بدون بازنویسی کنار بیایید، با بهبود طراحی سیستم در یک سری گام‌های ساده.

[^1]: توسعه‌دهندگان می‌توانند نسبت به فناوری‌هایی که با آن‌ها کار می‌کنند بسیار متعصب باشند. 
برای جلوگیری از ناراحت کردن کاربران برخی فناوری‌ها، هیچ فناوری خاصی در اینجا ذکر نشده است.

[^2]:  Bugzilla به دلایل مختلف، در طول سال‌ها، بارها به این شکل بازطراحی شده است. اگر می‌خواهید تاریخچه کارهای عمده‌ای که انجام شده را ببینید، می‌توانید به موارد خط خورده در اینجا نگاه کنید:
 https://bugzilla.mozilla.org/showdependencytree.cgi?id=278579&hide_resolved=0 
اگر فقط به جزئیات بیشتری در مورد نحوه انجام کارهای پایگاه داده نیاز دارید، به موارد خط خورده در اینجا نگاه کنید: 
https://bugzilla.mozilla.org/showdependencytree.cgi?id=98304&hide_resolved=0 خواندن عنوان هر مورد باید به شما ایده‌ای از نحوه انجام پروژه بدهد، اگر با سیستم‌های پایگاه داده آشنا هستید
