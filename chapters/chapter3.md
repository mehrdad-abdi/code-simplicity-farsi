# فصل ۳: آینده
سؤال اصلی که پیش روی طراحان نرم‌افزار قرار دارد این است: 
"چگونه درباره نرم‌افزار خود تصمیم بگیرم؟" 
وقتی با گزینه‌های مختلفی مواجه هستید، کدام گزینه بهترین است؟ 
مسئله این نیست که کدام تصمیم کاملاً درست یا کاملاً اشتباه است. 
بلکه می‌خواهیم بدانیم: 
«از بین تصمیمات ممکن، کدام‌یک بهتر از بقیه است؟» 
این مسئله رتبه‌بندی تصمیمات است و سپس انتخاب بهترین تصمیم از میان همه احتمالات. 
برای مثال، یک طراح ممکن است از خود بپرسد: 
«ما می‌توانیم امروز روی ۱۰۰ ویژگی مختلف کار کنیم، اما فقط نیروی انسانی برای کار روی دو ویژگی داریم. کدام‌ها را باید اول انجام دهیم؟»


## معادله طراحی نرم‌افزار

پرسش بالا، و در واقع هر پرسش دیگری از این نوع در طراحی نرم‌افزار، با این معادله پاسخ داده می‌شود:

$$D=\frac{V}{E}$$

که در آن:
- **D**: 
نمایانگر مطلوبیت تغییر است. 
چقدر می‌خواهیم کاری انجام شود؟
- **V**: 
نمایانگر ارزش تغییر است.
چقدر این تغییر ارزشمند است؟
معمولاً می‌توانید با پرسیدن «چقدر این تغییر به کاربران ما کمک می‌کند؟» ارزش را تعیین کنید، هرچند روش‌های دیگری نیز برای تعیین ارزش وجود دارد.
- **E**: 
نمایانگر تلاش لازم برای انجام تغییر است. 
چقدر کار برای انجام تغییر لازم است؟

به طور اساسی، این معادله می‌گوید:

**مطلوبیت هر تغییری نسبت مستقیم با ارزش آن تغییر و نسبت معکوس با تلاشی که برای انجام آن لازم است دارد.**

این معادله به شما نمی‌گوید که آیا یک تغییر مطلقاً درست یا اشتباه است؛ بلکه به شما کمک می‌کند گزینه‌های خود را رتبه‌بندی کنید. 
تغییراتی که ارزش زیادی دارند و نیاز به تلاش کمی دارند «بهتر» از آنهایی هستند که ارزش کمی دارند و نیاز به تلاش زیادی دارند.

حتی اگر سوال شما این باشد که «آیا باید ثابت بمانیم و تغییری ایجاد نکنیم؟»، این معادله باز هم به شما پاسخ می‌دهد. 
از خود بپرسید: «ارزش ثابت ماندن چقدر است؟» و «تلاش برای ثابت ماندن چقدر است؟» و سپس آن را با ارزش تغییر و تلاشی که برای تغییر لازم است مقایسه کنید.

### ارزش

منظور ما از «ارزش» در این معادله چیست؟ 
ساده‌ترین تعریف ارزش این است:

**مقدار کمکی که این تغییر به هر کس در هر موقعیت می‌کند.**

مهم‌ترین افرادی که باید به آنها کمک شود، کاربران شما هستند. 
با این حال، اضافه کردن ویژگی‌هایی که به شما کمک کند تا خود را از نظر مالی حمایت کنید نیز نوعی ارزش است — این برای شما ارزش دارد. 
در واقع، روش‌های مختلفی وجود دارد که یک تغییر می‌تواند ارزشمند باشد؛ اینها فقط دو مثال هستند.

گاهی تعیین ارزش دقیق عددی برای هر تغییر خاص دشوار است. 
برای مثال، بگویید نرم‌افزار شما به افراد کمک می‌کند تا وزن کم کنند. 
چگونه می‌توانید ارزش دقیق کمک به کسی برای کاهش وزن را اندازه‌گیری کنید؟ 
واقعاً نمی‌توانید. 
اما می‌توانید با دقت بگویید که برخی ویژگی‌های نرم‌افزار کمک بیشتری به افراد در کاهش وزن می‌کند و برخی ویژگی‌ها اصلاً به آنها کمک نمی‌کند. 
بنابراین، همچنان می‌توانید تغییرات را بر اساس ارزش آنها رتبه‌بندی کنید. 
درک ارزش هر تغییر ممکن عمدتاً از تجربه به عنوان یک توسعه‌دهنده و انجام تحقیقات مناسب با کاربران به‌دست می‌آید تا بفهمید چه چیزی به آنها بیشتر کمک می‌کند.

#### احتمال ارزش و ارزش بالقوه

ارزش در واقع از دو عامل تشکیل شده است: 
*احتمال ارزش* (چقدر احتمال دارد که این تغییر به یک کاربر کمک کند) و *ارزش بالقوه* (چقدر این تغییر در مواقعی که به کاربر کمک می‌کند، ارزشمند خواهد بود).

برای مثال:
- یک ویژگی که می‌تواند جان کسی را نجات دهد، حتی اگر فقط یک در میلیون احتمال وجود داشته باشد که مورد نیاز واقع شود، همچنان یک ویژگی بسیار باارزش است. 
این ویژگی ارزش بالقوه بالایی دارد (نجات جان)، حتی اگر احتمال ارزش آن پایین باشد.
مثال دیگر اینکه در یک برنامه صفحه‌گسترده، ممکن است ویژگی‌ای اضافه کنید که به افراد نابینا کمک کند اعداد را وارد کنند. 
فقط درصد کمی از افراد نابینا هستند، اما بدون این ویژگی، آنها نمی‌توانند از نرم‌افزار شما استفاده کنند. 
این ویژگی ارزشمند است زیرا ارزش بالقوه بسیار بالایی دارد، هرچند فقط گروه کوچکی از کاربران را تحت تأثیر قرار می‌دهد (احتمال ارزش پایین است).
- اگر یک ویژگی وجود داشته باشد که باعث شود ۱۰۰٪ از کاربران شما لبخند بزنند، آن ویژگی نیز ارزشمند است. 
احتمال ارزش آن بسیار بالاست، اما ارزش بالقوه‌اش (لبخند زدن کاربران) ممکن است نسبتاً کم باشد.
- از طرف دیگر، اگر شما ویژگی‌ای را پیاده‌سازی کنید که فقط یک در میلیون احتمال دارد باعث لبخند کسی شود، آن ویژگی چندان ارزشمند نیست. 
این ویژگی دارای ارزش بالقوه کم و احتمال ارزش پایین است.

بنابراین، هنگام بررسی ارزش، شما باید این موارد را در نظر بگیرید:
- چند نفر (چه درصدی از کاربران) این تغییر را باارزش می‌دانند؟
- احتمال اینکه این ویژگی برای یک کاربر مفید باشد چقدر است؟ 
یا به بیان دیگر: هر چند وقت یکبار این ویژگی برای کاربران مفید خواهد بود؟
- وقتی که این ویژگی مفید است، چقدر مفید خواهد بود؟

#### توازن آسیب

برخی تغییرات ممکن است علاوه بر کمکی که به کاربران می‌کنند، آسیب‌هایی نیز به همراه داشته باشند. 
برای مثال، ممکن است برخی کاربران از نمایش تبلیغات در نرم‌افزار شما ناراحت شوند، حتی اگر این تبلیغات به حمایت مالی شما به عنوان توسعه‌دهنده کمک کند.

محاسبه ارزش یک تغییر شامل در نظر گرفتن میزان آسیبی است که ممکن است ایجاد کند و مقایسه آن با کمکی که ارائه می‌دهد.

#### ارزش استفاده توسط کاربران

ویژگی‌هایی که هیچ کاربری ندارند، هیچ ارزشی ندارند. 
این شامل ویژگی‌هایی می‌شود که کاربران نمی‌توانند پیدا کنند، ویژگی‌هایی که استفاده از آنها خیلی دشوار است، یا ویژگی‌هایی که به هیچ کس کمک نمی‌کنند. 
شاید در آینده ارزش پیدا کنند، اما در حال حاضر هیچ ارزشی ندارند.

این همچنین به این معنی است که در بیشتر موارد، نرم‌افزار شما باید ابتدا منتشر شود تا ارزشمند باشد. 
یک تغییری که بیش از حد طول بکشد تا پیاده‌سازی‌اش تمام شود ممکن است در نهایت هیچ ارزشی نداشته باشد، زیرا به موقع عرضه نشده است تا به مردم کمک کند. 
در نظر گرفتن زمانبندی‌های عرضه هنگام تعیین مطلوبیت تغییرات می‌تواند مهم باشد.

### تلاش

تلاش کمی آسان‌تر از ارزش به اعداد تبدیل می‌شود. 
معمولاً می‌توانید تلاش را به صورت «تعداد ساعاتی از کار توسط تعداد مشخصی از افراد» توصیف کنید. 
«یکصد نفر-سال» یک مثال از اندازه‌گیری رایج برای تلاش است که نشان‌دهنده ۱۰۰ سال کار توسط یک نفر، یا ۱ سال کار توسط ۱۰۰ نفر، یا ۲ سال کار توسط ۵۰ نفر است، و به همین ترتیب.

با این حال، حتی اگر تلاش را بتوان به اعداد تبدیل کرد، اندازه‌گیری آن در موقعیت‌های عملی بسیار دشوار است — شاید حتی غیرممکن. 
تغییرات می‌توانند هزینه‌های پنهانی زیادی داشته باشند که پیش‌بینی آنها دشوار است، مانند زمانی که در آینده صرف رفع باگ‌هایی که تغییرات ایجاد کرده‌اند، خواهید کرد. 
اما اگر یک توسعه‌دهنده نرم‌افزار با تجربه باشید، همچنان می‌توانید تغییرات را بر اساس میزان تلاشی که به احتمال زیاد نیاز دارند، رتبه‌بندی کنید، حتی اگر دقیقاً اعداد هر کدام را ندانید.

هنگام بررسی تلاشی که برای یک تغییر لازم است، مهم است که تمام تلاش‌هایی که ممکن است دخیل باشند را در نظر بگیرید، نه فقط زمانی که برای برنامه‌نویسی صرف می‌کنید. 
چقدر تحقیق لازم است؟ چقدر ارتباط بین توسعه‌دهندگان مورد نیاز خواهد بود؟ چقدر زمان صرف فکر کردن به این تغییر خواهید کرد؟

به طور خلاصه، هر قطعه زمانی که به یک تغییر متصل است، بخشی از هزینه تلاش است.

### نگهداری

معادله‌ای که تا اینجا داریم بسیار ساده است، اما یک عنصر مهم را از دست داده است — زمان. 
شما نه تنها باید تغییر را پیاده‌سازی کنید، بلکه باید در طول زمان آن را نگهداری کنید. 
همه تغییرات نیاز به نگهداری دارند. 
این مسئله در مورد برخی تغییرات واضح است — اگر در حال نوشتن برنامه‌ای برای انجام مالیات هستید، باید هر سال آن را برای قوانین مالیاتی جدید به‌روزرسانی کنید. 
اما حتی تغییراتی که در ابتدا به نظر نمی‌رسند هزینه نگهداری طولانی مدتی داشته باشند، در نهایت خواهند داشت، حتی اگر فقط هزینه تست دوباره آن کد باشد تا مطمئن شوید که سال آینده همچنان کار می‌کند.

همچنین باید هم ارزش در حال حاضر و هم ارزش در آینده را در نظر بگیرید. 
وقتی تغییری را در سیستم خود پیاده‌سازی می‌کنید، این تغییر به کاربران فعلی شما کمک می‌کند، اما ممکن است به تمام کاربران آینده شما نیز کمک کند. 
حتی ممکن است تعداد کاربران آینده را تحت تأثیر قرار دهد و در نتیجه میزان کلی کمکی که نرم‌افزار شما در طول زمان به مردم می‌کند تغییر کند.

برخی ویژگی‌ها حتی در طول زمان تغییر ارزش می‌دهند. 
برای مثال، داشتن یک برنامه مالیاتی که قوانین مالیاتی سال ۲۰۰۹ را درک می‌کند، در سال ۲۰۰۹ و ۲۰۱۰ باارزش است، اما با آمدن سال ۲۰۱۱ دیگر آن‌قدر ارزشمند نیست. 
این یک ویژگی است که با گذشت زمان کمتر ارزشمند می‌شود. 
برخی ویژگی‌ها نیز ممکن است با گذشت زمان باارزش‌تر شوند.

بنابراین، با در نظر گرفتن واقعیت، می‌بینیم که تلاش در واقع شامل تلاش پیاده‌سازی و تلاش نگهداری است و ارزش شامل ارزش کنونی و ارزش آینده است. 
به صورت معادله‌ای، این به شکل زیر است:

$$E = E_i + E_m$$

$$V = V_n + V_f$$

که در آن:
- $E_i$ نشان‌دهنده تلاش پیاده‌سازی است.
- $E_m$ نشان‌دهنده تلاش نگهداری است.
- $V_n$ نشان‌دهنده ارزش کنونی است.
- $V_f$ نشان‌دهنده ارزش آینده است.

### معادله کامل

با وارد کردن همه چیز، معادله کامل به این شکل است:

$$D = \frac{V_n+V_f}{E_i+E_m}$$

یا به بیان ساده:

**مطلوبیت یک تغییر نسبت مستقیم با ارزش کنونی و ارزش آینده و نسبت معکوس با تلاش پیاده‌سازی و تلاش نگهداری دارد.**

این قانون اصلی طراحی نرم‌افزار است. 
با این حال، هنوز چیزهای بیشتری برای دانستن درباره آن وجود دارد.

### ساده کردن معادله

«ارزش آینده» و «تلاش نگهداری» هر دو به زمان وابسته هستند، که باعث می‌شود در هنگام اعمال این معادله در موقعیت‌های دنیای واقعی، چیزهای جالبی اتفاق بیفتد. 
برای نشان دادن این موضوع، فرض کنید می‌توانیم از پول برای حل معادله در هر دو طرف ارزش و تلاش استفاده کنیم. 
«ارزش» با این اندازه‌گیری می‌شود که این تغییر چقدر برای ما درآمد ایجاد خواهد کرد. 
«تلاش» با این اندازه‌گیری می‌شود که چقدر هزینه خواهد داشت تا آن تغییر را پیاده‌سازی کنیم. 
شما نباید در دنیای واقعی از این معادله به این شکل استفاده کنید، اما برای مثال ما، این رویکرد باعث ساده‌تر شدن موضوع خواهد شد.
پس، فرض کنیم تغییری داریم که می‌خواهیم اعمال کنیم و معادله به این شکل است:

$$D = \frac{$10,000 + $1,000 \text{
روزانه
}}{$1,000 + $100 \text{
روزانه
}}
$$

به عبارت دیگر، این تغییر ۱۰۰۰ دلار برای پیاده‌سازی (تلاش پیاده‌سازی، پایین سمت چپ) هزینه دارد و بلافاصله ۱۰۰۰۰ دلار برای ما ایجاد می‌کند (ارزش کنونی، بالا سمت چپ). 
سپس، هر روز پس از آن، ۱۰۰۰ دلار برای ما درآمد دارد (ارزش آینده، بالا سمت راست) و ۱۰۰ دلار هزینه نگهداری آن است (تلاش نگهداری، پایین سمت راست).

پس از ۱۰ روز، ارزش آینده انباشته شده به ۱۰,۰۰۰ دلار می‌رسد و تلاش نگهداری به ۱,۰۰۰ دلار می‌رسد. 
این برابر است با «ارزش کنونی» اصلی و هزینه پیاده‌سازی پس از فقط ۱۰ روز.

پس از ۱۰۰ روز، ارزش آینده به ۱۰۰,۰۰۰ دلار می‌رسد و تلاش نگهداری به ۱۰,۰۰۰ دلار می‌رسد.

پس از ۱,۰۰۰ روز، ارزش آینده کل به ۱,۰۰۰,۰۰۰ دلار می‌رسد و تلاش نگهداری به ۱۰۰,۰۰۰ دلار می‌رسد. 
در این نقطه، «ارزش کنونی» اصلی و هزینه پیاده‌سازی بسیار ناچیز به نظر می‌رسد. 
با گذشت زمان، این موارد حتی کمتر اهمیت پیدا می‌کنند و در نهایت کاملاً از اهمیت خارج می‌شوند. 
بنابراین، با گذشت زمان، معادله ما به این شکل ساده می‌شود[^1]:

$$D = \frac{V_f}{E_m}$$

در واقع، تقریباً تمام تصمیمات در طراحی نرم‌افزار به اندازه‌گیری ارزش آینده یک تغییر در مقابل تلاش نگهداری آن تقلیل می‌یابد. 
موقعیت‌هایی وجود دارد که در آن ارزش کنونی و تلاش پیاده‌سازی به اندازه کافی بزرگ هستند که در یک تصمیم مهم باشند، اما این موارد بسیار نادر هستند. 
به طور کلی، سیستم‌های نرم‌افزاری به قدری طولانی مدت نگهداری می‌شوند که ارزش کنونی و تلاش پیاده‌سازی تقریباً در تمام موارد، در مقایسه با ارزش آینده بلندمدت و تلاش نگهداری، ناچیز می‌شوند.

### چه چیزی می‌خواهید و چه چیزی نمی‌خواهید

درس اصلی که باید اینجا یاد بگیریم این است که می‌خواهیم از موقعیت‌هایی که در آن‌ها، برای یک تغییر خاص، تلاش برای نگهداری در نهایت از ارزش آینده بیشتر می‌شود، اجتناب کنیم. 
به عنوان مثال، تصور کنید که تغییری را پیاده‌سازی می‌کنید که تلاش و ارزش آن در طول پنج روز به این شکل است:


| روز | تلاش | ارزش |
| --- | --- | --- |
| 1 | $10 | $1000 |
| 2 | $100 | $100 |
| 3 | $1000 | $10 |
| 4 | $10000 | $1 |
| 5 | $100000 | $0.10 |
| جمع | $111110 | $1111.10 |

واضح است که این یک تغییر بسیار بد است که هرگز نباید انجام می‌دادید. 
اگر اوضاع به همین منوال ادامه یابد، اصلاً قادر به نگهداری سیستم نخواهید بود—هزینه‌ها به طور بی‌نهایت افزایش می‌یابد و ارزشی که هر روز به دست می‌آورید به صفر می‌رسد. 
هر موقعیتی که در آن تلاش برای نگهداری سریع‌تر از ارزش افزایش یابد، شما را به دردسر می‌اندازد، حتی اگر در ابتدا خوب به نظر برسد:

| روز | تلاش | ارزش |
| --- | --- | --- |
| 1 | $1000 | $1000 |
| 2 | $2000 | $2000 |
| 3 | $4000 | $3000 |
| 4 | $8000 | $4000 |
| جمع | $15,000 | $10,000 |

راه‌حل ایده‌آل—و تنها راه برای تضمین موفقیت—این است که سیستم‌های خود را به گونه‌ای طراحی کنید که تلاش برای نگهداری در طول زمان کاهش یابد و در نهایت به صفر برسد (یا تا حد ممکن نزدیک به آن شود). 
تا زمانی که بتوانید این کار را انجام دهید، مهم نیست که ارزش آینده چقدر بزرگ یا کوچک باشد؛ نیازی به نگرانی در مورد آن ندارید. 
به عنوان مثال، این جداول موقعیت‌های مطلوب را نشان می‌دهند:

| روز | تلاش | ارزش |
| --- | --- | --- |
| 1 | $1000 | $0 |
| 2 | $100 | $10 |
| 3 | $10 | $100 |
| 4 | $0 | $1000 |
| 5 | $0 | $10000 |
| جمع | $1,110 | $11,110 |


| روز | تلاش | ارزش |
| --- | --- | --- |
| 1 | $20 | $10 |
| 2 | $10 | $10 |
| 3 | $5 | $10 |
| 4 | $1 | $10 |
| 5 | $0 | $10 |
| جمع | $36 | $50 |

تغییراتی که ارزش آینده بالاتری دارند همچنان مطلوب‌تر هستند، اما تا زمانی که هر تصمیمی هزینه نگهداری‌ای داشته باشد که با گذشت زمان به صفر نزدیک شود، نمی‌توانید خود را در یک وضعیت خطرناک آینده قرار دهید.

به طور نظری، تا زمانی که ارزش آینده همیشه بیشتر از تلاش نگهداری باشد، تغییر همچنان مطلوب است. 
بنابراین، شما می‌توانید تغییری ایجاد کنید که در آن تلاش نگهداری و ارزش آینده هر دو افزایش یابند، به شرطی که ارزش آینده به اندازه کافی بزرگ باقی بماند تا تلاش نگهداری را جبران کند:


| روز | تلاش | ارزش |
| --- | --- | --- |
| 1 | $1 | $0 |
| 2 | $2 | $2 |
| 3 | $3 | $4 |
| 4 | $4 | $6 |
| 5 | $5 | $8 |
| جمع | $15 | $20 |

چنین تغییری بد نیست، اما مطلوب‌تر است که تغییری انجام شود که تلاش نگهداری آن کاهش یابد، حتی اگر نیاز به تلاش پیاده‌سازی بیشتری داشته باشد. 
اگر تلاش نگهداری در طول زمان کاهشی باشد، این تغییر مطلوبیت بیشتری پیدا می‌کند و آن را به انتخاب بهتری نسبت به سایر احتمالات تبدیل می‌کند.
اغلب، طراحی سیستمی که تلاش نگهداری کاهشی دارد، نیاز به تلاش پیاده‌سازی بیشتری دارد—تا حدی طراحی و برنامه‌ریزی بیشتری لازم دارد. 
با این حال، به یاد داشته باشید که تلاش پیاده‌سازی تقریباً همیشه یک عامل ناچیز در تصمیمات طراحی است و باید تا حد زیادی نادیده گرفته شود.

به طور خلاصه: 

**مهم‌تر است که تلاش نگهداری را کاهش دهیم تا اینکه تلاش پیاده‌سازی را کاهش دهیم.**

این یکی از مهم‌ترین چیزهایی است که باید درباره طراحی نرم‌افزار بدانیم.

اما چه چیزی باعث تلاش نگهداری می‌شود؟ 
چگونه سیستم‌هایی طراحی کنیم که تلاش نگهداری آن‌ها در طول زمان کاهش یابد؟ 
این موضوع بیشتر محتوای باقی مانده این کتاب است. 
اما قبل از اینکه به آن برسیم، باید کمی بیشتر به آینده نگاه کنیم.

## کیفیت طراحی

نوشتن نرم‌افزاری که به یک نفر در همین لحظه کمک کند، بسیار آسان است. نوشتن نرم‌افزاری که به میلیون‌ها نفر در زمان حال و همچنین دهه‌های آینده کمک کند، بسیار دشوار است. اما نیاز به سعی در برنامه‌نویسی کی بیشتر خواهد بود؟ همین حالا یا در دهه‌های آینده؟ بیشترین تعداد کاربران چه زمانی خواهند بود؟ همین حالا یا در دهه‌های آینده؟

پاسخ این است که نرم‌افزار شما در آینده حجم برنامه‌نویسی بسیار بیشتری نسبت به آنچه در حال حاضر وجود دارد خواهد داشت—و همچنین تعداد کاربران بیشتری نیز وجود خواهد داشت که به آن‌ها کمک شود. نرم‌افزار شما باید در آینده وجود داشته باشد و با رقبایش رقابت کند درحالیکه تلاش نگهداری و تعداد کاربران در آن نیز در طول زمان افزایش خواهد یافت.

وقتی نادیده می‌گیریم که آینده‌ای وجود دارد و فقط نرم‌افزاری می‌سازیم که در حال حاضر "فقط کار کند"، نرم‌افزار ما در آینده سخت‌تر نگهداری می‌شود. وقتی نگهداری نرم‌افزار سخت باشد، ادامه دادن به کمک به افراد (که یکی از اهداف ما در طراحی نرم‌افزار است) دشوار می‌شود. اگر نتوانید ویژگی‌های جدید اضافه کنید و نتوانید مشکلات را رفع کنید، در نهایت به "نرم‌افزار بد" خواهید رسید. نرم‌افزار قادر به کمک به کاربران نخواهد شد و مملو از باگ می‌شود.

این ما را به قانون زیر می‌رساند:

 **سطح کیفیت طراحی شما باید متناسب با مدت زمانی باشد که سیستم شما به کمک به مردم ادامه خواهد داد.**
 
اگر در حال نوشتن نرم‌افزاری هستید که تنها برای چند ساعت آینده استفاده خواهد شد، نیازی نیست خیلی تلاش زیادی در طراحی آن انجام دهید. اما اگر نرم‌افزار شما ممکن است برای 10 سال آینده استفاده شود (که این بسیار بیشتر از آن چیزی که انتظار دارید اتفاق می‌افتد، حتی اگر فکر کنید فقط برای 6 ماه آینده استفاده خواهد شد)، باید تلاش زیادی در طراحی آن انجام دهید. اگر شک دارید، نرم‌افزار خود را طوری طراحی کنید که انگار برای مدت طولانی استفاده خواهد شد: خود را به یک روش خاص برای انجام کارها محدود نکنید، نرم‌افزار را انعطاف‌پذیر نگه دارید، تصمیماتی که هرگز نمی‌توانید تغییر دهید نگیرید و توجه زیادی به طراحی داشته باشید.

## پیامدهای غیرقابل پیش‌بینی

پس، وقتی نرم‌افزار طراحی می‌کنیم، آینده باید تمرکز اصلی ما باشد. با این حال، یکی از مهم‌ترین چیزهایی که در هر نوع مهندسی باید بدانیم این است:

**چیزهای در آینده منتظر شماست که اکنون از آن مطلع نیستید.**

در واقع، وقتی صحبت از طراحی نرم‌افزار می‌شود، نمی‌توانید اکثر چیزهای مربوط به آینده را بدانید. 
رایج‌ترین و فاجعه‌بارترین اشتباهی که برنامه‌نویسان مرتکب می‌شوند این است که چیزی را درباره آینده پیش‌بینی می‌کنند، در حالی که در واقع نمی‌توانند آن را بدانند.

به عنوان مثال، تصور کنید که یک برنامه‌نویس در سال 1985 یک قطعه نرم‌افزار نوشت که دیسک‌های فلاپی خراب را تعمیر می‌کرد. نمی‌توانست هیچ چیز دیگری را تعمیر کند—هر بخش از آن کاملاً به نحوه کار دیسک‌های فلاپی وابسته بود. آن نرم‌افزار اکنون منسوخ شده است، زیرا مردم دیگر از دیسک‌های فلاپی استفاده نمی‌کنند. پیش‌بینی آن برنامه‌نویس این بود که "مردم همیشه از دیسک‌های فلاپی استفاده خواهند کرد"—چیزی که واقعاً نمی‌توانست بداند.

شاید امکان پیش‌بینی آینده کوتاه‌مدت ممکن است باشد، اما آینده بلندمدت تا حد زیادی ناشناخته است. آینده بلندمدت نیز برای ما از آینده کوتاه‌مدت مهم‌تر است، زیرا تصمیمات طراحی ما در آن دوره طولانی‌تر پیامدهای بیشتری خواهند داشت.

> شما در امان‌تر هستید اگر اصلاً سعی نکنید آینده را پیش‌بینی کنید و در عوض تمام تصمیمات طراحی خود را بر اساس اطلاعات موجود در زمان حال بگیرید.

ممکن است فکر کنید این موضوع دقیقاً برعکس چیزی به نظر برسد که تاکنون در این فصل گفته‌ایم، اما اینطور نیست. آینده مهم‌ترین چیزی است که باید در تصمیم‌گیری‌های طراحی در نظر گرفت. اما این ایده که طراحی به شکلی باشد که اجازه تغییرات در آینده را بدهد با تلاش برای پیش‌بینی آینده متفاوت است.

به عنوان یک مثال، فرض کنید که شما یک انتخاب ساده بین غذا خوردن و از گرسنگی مردن دارید. شما نیازی به پیش‌بینی آینده ندارید تا این انتخاب را انجام دهید—می‌دانید که غذا خوردن انتخاب بهتری است. چرا؟ زیرا باعث می‌شود که همین حالا زنده بمانید و می‌دانید که زنده بودن در آینده نسبت به مردن بهتر است. آینده مهم است و ما می‌خواهیم آن را در تصمیمات خود در نظر بگیریم. ما الان غذا می‌خوریم زیرا این کار باعث آینده بهتری می‌شود. اما نیازی نیست که آینده را پیش‌بینی کنیم—لازم نیست چیزی خاص مانند "من الان غذا می‌خورم زیرا فردا باید جان یک کودک را نجات دهم" بگوییم. مهم نیست فردا چه اتفاقی می‌افتد، اگر اکنون غذا بخورید به جای اینکه از گرسنگی بمیرید، فردای بهتری خواهید داشت.

به همین ترتیب، در طراحی نرم‌افزار می‌توانیم بر اساس اطلاعاتی که اکنون در اختیار داریم تصمیماتی بگیریم که به منظور ایجاد آینده بهتر (مبتنی بر کاهش نیاز به تلاش نگهداری و ارزش افزایشی) باشند، بدون اینکه مجبور به پیش‌بینی جزئیات آینده باشیم.
استثناهایی محدود وجود دارد—گاهی شما دقیقاً می‌دانید که در آینده نزدیک چه اتفاقی خواهد افتاد و می‌توانید بر اساس آن تصمیم بگیرید. اما اگر قرار است این کار را انجام دهید، باید از آن آینده بسیار مطمئن باشید و آن آینده حتما آینده‌ی بسیار نزدیکی است. درحالیکه هیچ راه ممکن و دقیقی برای پیش‌بینی آینده‌های بلندمدت وجود ندارد، فارغ از اینکه شما چقدر باهوش هستید.

بیایید مثالی از خارج از حوزه برنامه‌نویسی بزنیم: سی‌دی‌ها، که در سال ۱۹۷۹ طراحی شدند تا جایگزین نوارهای کاست به عنوان روش اصلی گوش دادن به موسیقی شوند. چه کسی می‌توانست پیش‌بینی کند که ۲۰ سال بعد دی‌وی‌دی‌ها در همان اندازه و شکل ساخته شوند تا تولیدکنندگان بتوانند درایوهای سی‌دی/دی‌وی‌دی را برای کامپیوترها بسازند؟ و چه کسی می‌توانست مشکلات چرخاندن یک سی‌دی با سرعت ۵۰ برابر بیشتر از سرعت معمول درون درایوهای خواننده سی‌دی-رام را تصور کند؟

به همین دلیل در هر نوع مهندسی—از جمله توسعه نرم‌افزار—ما شاهد یک سری "اصول راهنما" هستیم. این‌ها قوانینی هستند که وقتی آن‌ها را دنبال می‌کنیم، همه چیز به خوبی کار می‌کند، بدون نیاز به نگرانی درباره آنچه در آینده اتفاق خواهد افتاد. قوانین و اصول طراحی نرم‌افزار که در این کتاب صحبت شده‌اند نیز مشابه همان "اصول راهنمای" ما به عنوان طراحان هستند.

پس بله، مهم است که به یاد داشته باشید که آینده‌ای وجود خواهد داشت. اما این به این معنا نیست که شما باید آن آینده را پیش‌بینی کنید. بلکه این توضیح می‌دهد که چرا باید بر اساس قوانین و اصول این کتاب تصمیم بگیرید—زیرا آن‌ها به نرم‌افزار خوبی در آینده منجر می‌شوند، بدون توجه به اینکه آن آینده چه چیزی با خود می‌آورد.

پیش‌بینی این موضوع که این قوانین در آینده به چه روش‌هایی به شما کمک می‌کند نیز حتی ممکن نیست—اما مطمئن باشید که کمک خواهد کرد و در آینده از اینکه آن را در کار خود اعمال کرده‌اید خوشحال خواهید شد.
شما آزاد هستید که با قوانین، اصول و حقایقی که اینجا می‌خوانید مخالف باشید. لطفاً خودتان در مورد آن‌ها به نتیجه برسید. اما باید به شما هشدار داد که اگر آن‌ها را دنبال نکنید، احتمالاً در آینده‌ای که نمی‌توانید پیش‌بینی کنید، درگیر مشکلات بزرگی خواهید شد.



[^1]: توضیح اختیاری برای ریاضی‌دانان: اگر حساب دیفرانسیل و انتگرال را مطالعه کرده‌اید، ممکن است متوجه شده باشید که ما شروع به تحلیل حد معادله با نزدیک شدن زمان به بی‌نهایت کرده‌ایم. به طور کلی، باید به معادله طراحی نرم‌افزار به عنوان یک سری بی‌نهایت با حد فکر کنید، نه فقط یک معادله ثابت. با این حال، برای سادگی، اینجا به عنوان یک معادله ثابت نوشته شده است.


