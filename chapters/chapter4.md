فصل ۴:‌ تغییر
حال که درک می‌کنیم آینده چقدر اهمیت دارد و اینکه از همه چیز درباره آینده نمی‌توانیم با خبر باشیم، پس چه چیزی را درباره آن می‌توانیم بدانیم؟
خب، یکی از چیزهایی که می‌توانید مطمئن باشید این است که با گذشت زمان، محیط اطراف نرم‌افزار شما تغییر خواهد کرد. هیچ چیز برای همیشه ثابت نمی‌ماند. این به این معنی است که نرم‌افزار شما نیز باید تغییر کند تا با محیط اطرافش سازگار شود.
این ما را به قانون تغییر می‌رساند:
هرچه برنامه شما بیشتر عمر کند، احتمال اینکه هر قسمتی از آن نیاز به تغییر داشته باشد بیشتر می‌شود.
با گذشت زمان به سوی یک آینده بی‌نهایت، احتمال اینکه هر بخشی از برنامه شما نیاز به تغییر پیدا کند، به ۱۰۰ درصد میل می‌کند. در پنج دقیقه آینده، احتمالاً هیچ بخشی از برنامه شما نیازی به تغییر نخواهد داشت. در ده روز آینده، شاید بخش کوچکی از آن تغییر کند. در ۲۰ سال آینده، احتمالاً اکثریت (اگر نه همه) آن باید تغییر کند.
پیش‌بینی اینکه چه چیزی دقیقاً تغییر خواهد کرد و چرا، دشوار است. شاید شما برنامه‌ای برای خودروهای چهارچرخ نوشته‌اید، اما چه کسی می‌داند، شاید در آینده همه انسان‌ها کامیون‌های ۱۸ چرخ خواهند راند. شاید شما برنامه‌ای برای دانش‌آموزان دبیرستان نوشته‌اید، اما آموزش در دبیرستان‌ها آنقدر بد خواهد شد که دانش‌آموزان دیگر قادر به درک آن نخواهند بود.
نکته این است که نیازی نیست سعی کنید پیش‌بینی کنید چه چیزی تغییر خواهد کرد؛ فقط باید بدانید که تغییر خواهد کرد. نرم‌افزار خود را به گونه‌ای بنویسید که تا حد امکان انعطاف‌پذیر باشد و قادر به تطبیق با تغییرات آینده باشد.
بررسی تغییرات در یک برنامه‌ واقعی
بیایید نگاهی به داده‌هایی بیندازیم که نشان می‌دهد یک برنامه واقعی چگونه در طول زمان تغییر کرده است. در این برنامه صدها فایل وجود دارد، اما جزئیات هر فایل در این صفحه جا نمی‌شود، بنابراین چهار فایل به عنوان نمونه انتخاب شده‌اند. جزئیات این فایل‌ها در جدول زیر ارائه شده است.



فایل 1
فایل 2
فایل 3
فایل 4
دوره تحلیل
۵ سال و ۲ ماه
۸ سال و ۳ ماه
۱۳ سال و ۳ ماه
۱۳ سال و ۴ ماه
خطوط اولیه
۴۲۳
۱۹۲
۲۲۷
۳۰۹
خطوط تغییر نیافته
۲۷۱
۱۰۱
۴
۸
خطوط کنونی
۶۶۴
۹۴۸
۳۸۸
۴۱۴
میزان رشد
۲۴۱
۷۵۶
۱۶۱
۱۰۵
تعداد تغییرات
۴۷
۹۹
۱۹۴
۴۵۹
خطوط اضافه شده
۳۹۶
۱۰۲۶
۹۱۳
۳۸۲۸
خطوط حذف شده
۱۵۵
۲۷۰
۷۵۲
۳۷۲۳
خطوط اصلاح شده
۱۲۴
۴۱۳
۱۳۸۲
۳۵۵۶
مجموع تغییرات
۶۷۵
۱۷۰۹
۳۰۴۷
۱۱۱۰۷
نسبت تغییر
۱.۶ برابر
۸.۹ برابر
۱۳ برابر
۳۶ برابر


در این جدول:
دوره تحلیل: عمر فایل یا بازه زمانی که فایل در طول آن وجود داشته است.
خطوط اولیه: تعداد خطوطی که در زمان نوشته شدن اولیه فایل وجود داشتند.
خطوط تغییر نیافته: تعداد خطوطی که همچنان مشابه زمان نوشته شدن اولیه فایل هستند.
خطوط کنونی: تعداد خطوطی که در پایان دوره تحلیل در فایل وجود دارند.
میزان رشد: تفاوت بین "خطوط کنونی" و "خطوط اولیه".
تعداد تغییرات: تعداد کل دفعاتی که برنامه‌نویسی مجموعه‌ای از تغییرات را در فایل ایجاد کرده است (در یک مجموعه تغییرات، معمولاً چندین خط تغییر می‌کنند). معمولاً یک مجموعه تغییرات نمایانگر اصلاح یک باگ، اضافه کردن یک ویژگی جدید، و غیره است.
خطوط اضافه شده: تعداد دفعاتی که در تاریخچه فایل، یک خط جدید اضافه شده است.
خطوط حذف شده: تعداد دفعاتی که در تاریخچه فایل، یک خط حذف شده است.
خطوط اصلاح شده: تعداد دفعاتی که در تاریخچه فایل، یک خط تغییر کرده است (اما نه جدید اضافه شده و نه حذف شده است).
مجموع تغییرات: مجموع شمار "خطوط اضافه شده"، "خطوط حذف شده" و "خطوط اصلاح شده" برای آن فایل.
نسبت تغییر: چقدر "مجموع تغییرات" بزرگ‌تر از "خطوط اولیه" است.
وقتی از "خطوط" صحبت می‌کنیم، این شامل تمام خطوط در فایل‌ها می‌شود: کد، توضیحات (کامنت‌ها)، مستندات و خطوط خالی. اگر تحلیل بدون شمارش توضیحات، مستندات و خطوط خالی انجام شود، تفاوت اصلی‌ای که مشاهده می‌کنید این است که شمار "خطوط تغییر نیافته" نسبت به دیگر اعداد بسیار کوچک‌تر خواهد بود. (به عبارت دیگر، خطوط تغییر نیافته تقریباً همیشه توضیحات، مستندات یا خطوط خالی هستند.)
مهم‌ترین چیزی که از این جدول باید فهمید این است که تغییرات زیادی در یک پروژه نرم‌افزاری اتفاق می‌افتد. با گذشت زمان، احتمال تغییر هر خط از کد بیشتر می‌شود، اما نمی‌توانید پیش‌بینی کنید که دقیقاً چه چیزی، چه زمانی یا به چه مقدار تغییر خواهد کرد. هر یک از این چهار فایل به شیوه‌های بسیار متفاوتی تغییر کرده‌اند (حتی با نگاه به اعداد می‌توانید این را ببینید)، اما همگی تغییرات قابل توجهی داشته‌اند.
چند نکته جالب دیگر در مورد این اعداد وجود دارد:
با نگاهی به نسبت تغییرات، می‌بینیم که حجم کار بیشتری برای تغییر هر فایل نسبت به نوشتن اولیه آن انجام شده است. به وضوح، تعداد خطوط تخمین دقیقی از میزان کاری که واقعاً انجام شده نیست، اما به ما ایده کلی می‌دهد. گاهی اوقات این نسبت بسیار زیاد است—برای مثال، فایل ۴ تعداد تغییرات کلی ۳۶ برابر بیشتر از تعداد خطوط اصلی داشته است. 
تعداد خطوطی که در هر فایل بدون تغییر باقی مانده‌اند نسبت به "خطوط اصلی" کمتر و نسبت به "خطوط کنونی" بسیار کمتر است.
ممکن است تغییرات زیادی در یک فایل اتفاق بیفتد حتی اگر اندازه آن فایل با گذشت زمان تغییر چندانی نکند. برای مثال، فایل ۳ طی ۱۳ سال تنها ۱۶۱ خط بزرگ‌تر شد، اما در طول این مدت، شمار تغییرات کلی به ۳,۰۴۷ خط رسید. 
شمار تغییرات کلی همیشه بیشتر از تعداد خطوط کنونی است. به عبارت دیگر، اگر فایلی به مدتی طولانی وجود داشته باشد، احتمال اینکه ببینید یک خط در فایل تغییر کرده باشد بیشتر از این است که این خط از ابتدا در فایل وجود داشته باشد. 
در فایل ۳، تعداد خطوط تغییر یافته بیشتر از تعداد خطوط اصلی فایل به علاوه تعداد خطوط اضافه شده است. خطوط آن فایل بیشتر از خطوط جدید اضافه شده تغییر کرده‌اند. به عبارت دیگر، برخی از خطوط آن فایل بارها و بارها تغییر کرده‌اند. این موضوع در پروژه‌هایی که طول عمر بالایی دارند رایج است.
نکات بالا تمام آنچه که می‌توان از این اعداد یاد گرفت نیستند—تحلیل‌های جالب دیگری نیز می‌توان بر روی این اعداد انجام داد. شما تشویق می‌شوید که به این داده‌ها بپردازید (یا اعداد مشابهی را برای پروژه خود محاسبه کنید) و ببینید چه چیزهای دیگری می‌توانید بیاموزید.

یک فرصت یادگیری خوب دیگر این است که تاریخچه تغییرات ایجاد شده در یک فایل خاص را بررسی کنید. اگر رکوردی از هر تغییر ایجاد شده در فایل‌های برنامه خود دارید و یک فایل دارید که مدت زیادی است وجود دارد، سعی کنید هر تغییر ایجاد شده در طول عمر آن را بررسی کنید. فکر کنید که آیا می‌توانستید آن تغییر را زمانی که فایل در ابتدا نوشته شده بود پیش‌بینی کنید و در نظر بگیرید که آیا فایل می‌توانست در ابتدا بهتر نوشته شود تا تغییرات ساده‌تر شوند. به طور کلی، سعی کنید هر تغییر را درک کنید و ببینید آیا می‌توانید از این کار چیزی جدید در مورد توسعه نرم‌افزار یاد بگیرید.

سه اشتباه رایج
سه اشتباه کلی وجود دارد که طراحان نرم‌افزار هنگام تلاش برای مقابله با قانون تغییر مرتکب می‌شوند. این‌ها به ترتیب فراوانی ذکر شده‌اند:
نوشتن کدی که نیاز نیست
سخت کردن تغییر در کد
بیش از حد عمومی کردن کد
نوشتن کدی که نیاز نیست
امروزه یک قانون محبوب در طراحی نرم‌افزار وجود دارد که به آن "You Ain’t Gonna Need It" یا به اختصار YAGNI گفته می‌شود. به طور خلاصه، این قانون می‌گوید که نباید قبل از اینکه واقعاً به کدی نیاز داشته باشید، آن را بنویسید. این قانون خوبی است، اما نام‌گذاری‌اش دقیق نیست. در واقع ممکن است در آینده به آن کد نیاز داشته باشید، اما چون نمی‌توانید آینده را پیش‌بینی کنید، نمی‌دانید آن کد چگونه باید کار کند. اگر همین حالا آن را بنویسید، قبل از اینکه به آن نیاز داشته باشید، باید دوباره طراحی‌اش کنید تا با نیازهای واقعی شما مطابقت داشته باشد. بنابراین، هدف این است که خودتان را از آن زمان بازطراحی در آینده نجات دهید و تا زمانی که به کد نیاز ندارید، آن را ننویسید.
یکی دیگر از خطرات نوشتن کد قبل از نیاز به آن این است که کدهای استفاده نشده به تدریج دچار "کهنگی" می‌شوند. از آنجا که این کد هرگز اجرا نمی‌شود، ممکن است به تدریج با بقیه سیستم ناسازگار شود و در نتیجه دچار باگ‌هایی شود که شما هرگز از آن‌ها باخبر نخواهید شد. سپس، وقتی شروع به استفاده از آن می‌کنید، باید زمان زیادی را صرف رفع اشکالات آن کنید. یا، حتی بدتر از آن، ممکن است به کدی که هرگز استفاده نشده اعتماد کنید و آن را بررسی نکنید، و در نتیجه برای کاربران مشکلاتی ایجاد کند. در واقع، این قانون باید به این صورت گسترش یابد:
تا زمانی که واقعاً به کدی نیاز ندارید، آن را ننویسید و هر کدی که استفاده نمی‌شود را حذف کنید.
یعنی باید هر کدی که دیگر مورد نیاز نیست را هم حذف کنید. همیشه می‌توانید در صورت نیاز دوباره آن را اضافه کنید.

دلایل زیادی وجود دارد که مردم فکر می‌کنند باید کد را قبل از نیاز بنویسند یا کدی را که استفاده نمی‌شود نگه دارند. اول از همه، برخی افراد معتقدند که می‌توانند از قانون تغییر با برنامه‌ریزی تمام ویژگی‌هایی که هر کاربری ممکن است نیاز داشته باشد، همین حالا اجتناب کنند. سپس فکر می‌کنند که برنامه دیگر نیازی به تغییر یا بهبود نخواهد داشت. اما این اشتباه است. نمی‌توان سیستمی نوشت که نیاز به تغییر نداشته باشد درحالیکه که این سیستم توسط کاربران استفاده می‌شود.
برخی دیگر معتقدند که با انجام کار اضافی حالا، در آینده برای خودشان زمان می‌خرند. ممکن است در برخی موارد این کار به شما کمک اندکی بکند، اما نه زمانی که در حال نوشتن کدی هستید که به آن نیاز ندارید. حتی اگر در آینده به آن کد نیاز باشد، تقریباً حتماً باید زمان بیشتری را صرف بازطراحی آن کنید، بنابراین در واقع دارید وقت خود را تلف می‌کنید.
نوشتن کد غیرضروری: یک مثال واقعی
روزی روزگاری، یک توسعه‌دهنده — بیایید او را مکس بنامیم — به اشتباه فکر کرد که می‌تواند این قانون را نادیده بگیرد. در برنامه او، فهرست باز شونده‌ای (drop-down) وجود داشت که کاربران می‌توانستند از میان آن‌ها یک مقدار را انتخاب کنند. هر شرکتی که از برنامه استفاده می‌کرد، می‌توانست فهرست گزینه‌های نمایش‌داده‌شده در هر جعبه کشویی را سفارشی کند. برخی از شرکت‌ها ممکن بود از این لیست برای نام رنگ‌ها استفاده کنند. دیگران ممکن بود بخواهند که برای نام شهرها استفاده کنند. این گزینه‌ها می‌توانستند هر چیزی باشند. بنابراین، فهرست گزینه‌های معتبر باید جایی ذخیره می‌شد که هر شرکت بتواند آن را تغییر دهد.
این واضح بود که  فقط لازم است جایی فهرست مقادیر را ذخیره کنیم و بس. اما مکس تصمیم گرفت که دو چیز ذخیره کند: فهرست مقادیر و همچنین آیا هر مقدار در حال حاضر "فعال" است — یعنی، آیا کاربران می‌توانند آن مقدار را انتخاب کنند یا آن موقتاً غیرفعال شده است.
با این حال، مکس هرگز کدی برای استفاده از اطلاعات "فعال" بودن یا نبودن هر فیلد ننوشت. تمام گزینه‌ها همیشه فعال بودند، بدون توجه به داده‌های ذخیره‌شده. او مطمئن بود که قرار است به‌زودی کدی برای استفاده از اطلاعات "فعال" بنویسد — شاید حتی فردا.
چندین سال گذشت و کدی برای پردازش داده‌های "فعال" نوشته نشد. در عوض، داده‌ها آنجا نشستند، بدون استفاده، و مردم را گیج کردند و باعث ایجاد باگ‌هایی شدند. مشتریان و توسعه‌دهندگان زیادی به مکس نامه نوشتند و پرسیدند چرا وقتی آن‌ها به صورت دستی فهرست مقادیر را ویرایش کردند و گزینه‌ها را غیرفعال کردند، هیچ اتفاقی نیفتاد. یک توسعه‌دهنده به اشتباه تصور کرد که فیلد "فعال" در حال استفاده است و قطعه کدی نوشت که از آن استفاده می‌کرد، حتی با اینکه بقیه سیستم از آن استفاده نمی‌کرد. این به مشتریان رسید و آن‌ها شروع به گزارش باگ‌های عجیب‌وغریبی کردند که ردیابی آن‌ها زمان زیادی برد.
در نهایت، یک توسعه‌دهنده دیگر آمد و گفت: "امروز من قابلیت غیرفعال کردن گزینه‌ها را پیاده‌سازی خواهم کرد!" با این حال، او کشف کرد که فیلد "فعال" برای نیازهایش به‌طور کامل طراحی نشده است، بنابراین مجبور شد مقدار قابل‌توجهی کار بازطراحی انجام دهد تا ویژگی‌اش را پیاده‌سازی کند.
نتیجه نهایی: چندین باگ، سردرگمی زیاد، و کار اضافی برای توسعه‌دهنده‌ای که در نهایت واقعاً به آن کد نیاز داشت. و این یک نقض نسبتاً کوچک قانون بود! نقض‌های شدیدتر می‌توانند عواقب بسیار بدتری داشته باشند، از جمله از دست دادن ضرب‌الاجل‌ها، فاجعه‌های بزرگ، و شاید حتی نابودی پروژه نرم‌افزار شما.

سخت کردن تغییر کد
 یکی از بزرگترین قاتلان پروژه‌های نرم‌افزاری چیزی است که ما آن را “طراحی سخت” می‌نامیم. این زمانی است که یک برنامه‌نویس کدی را طراحی می‌کند که تغییر آن دشوار است. دو راه برای ایجاد یک طراحی سخت وجود دارد:
فرضیات زیادی در مورد آینده داشته باشید.
کد را بدون طراحی کافی بنویسید.


مثال: فرضیات بیش از حد در مورد آینده
یک آژانس دولتی—بیایید آن را "بیمارستان بازنشستگان" بنامیم—می‌خواهد یک برنامه ایجاد کند. ما این برنامه را "سیستم سلامت" می‌نامیم. قبل از ساختن این سیستم، این بیمارستان تصمیم می‌گیرد سندی بنویسد که دقیقاً مشخص کند کل سیستم چگونه باید پیاده‌سازی شود. آن‌ها یک سال را صرف نوشتن این سند می‌کنند و در این مدت هر تصمیم ممکن را درباره کل سیستم اتخاذ می‌کنند.
سپس، توسعه‌دهندگان سه سال را صرف نوشتن سیستم طبق این سند می‌کنند. در طول کار، آن‌ها متوجه می‌شوند که طراحی موجود در سند متناقض، ناقص و سخت برای پیاده‌سازی است. اما بیمارستان یک سال تمام را صرف نوشتن آن کرده است—توسعه‌دهندگان نمی‌توانند یک سال دیگر صبر کنند تا سند بازبینی شود. بنابراین آن‌ها سیستم را تا حد امکان نزدیک به سند پیاده‌سازی می‌کنند.
سیستم کامل شده و برای اولین بار به کاربران داده می‌شود. اما، در چهار سال گذشته وضعیت بیمارستان به شدت تغییر کرده است، و هنگامی که کاربران شروع به استفاده از "سیستم سلامت" می‌کنند، متوجه می‌شوند که چیز کاملاً متفاوتی می‌خواهند. اما سیستم از صدها هزار خط کد تشکیل شده است که همه به‌طور سفت و سخت مطابق سند طراحی شده‌اند—به‌راحتی نمی‌توان آن را بدون ماه‌ها یا سال‌ها تلاش تغییر داد.
بنابراین بیمارستان شروع به نوشتن سند جدیدی برای یک سیستم جدید می‌کند و این فرایند دوباره از نو آغاز می‌شود.
اشتباه بیمارستان این بود که سعی در پیش‌بینی آینده داشت. آن‌ها فرض کردند که هر تصمیمی که در سند گرفته‌اند برای کاربران واقعی معتبر است و وقتی سیستم کامل شود همچنان معتبر خواهد بود. اما وقتی آینده واقعی رسید، به‌هیچ‌وجه شبیه چیزی نبود که آن‌ها پیش‌بینی کرده بودند، و سیستم آن‌ها به یک شکست چند میلیون دلاری تبدیل شد.
یک راه‌حل بهتر این بود که فقط یک ویژگی یا مجموعه کوچکی از ویژگی‌ها را مشخص کنند و بلافاصله از توسعه‌دهندگان بخواهند آن را پیاده‌سازی کنند. سپس می‌توانست نوعی ارتباط دوطرفه و تست توسط کاربران در طول توسعه وجود داشته باشد. وقتی اولین مجموعه ویژگی‌ها انجام و منتشر شد، آن‌ها می‌توانستند روی ویژگی‌های اضافی کار کنند، یکی یکی، تا در نهایت سیستمی داشته باشند که به‌خوبی طراحی شده و به‌طور کامل نیازهای کاربران را برآورده می‌کند.



مثال: کدی بدون طراحی کافی
یک توسعه‌دهنده مأمور می‌شود برنامه‌ای ایجاد کند که مردم بتوانند از آن برای پیگیری کارهایی که باید انجام دهند، استفاده کنند. برای ایجاد یک "وظیفه" جدید در سیستم، کاربران فرمی را پر می‌کنند که شامل اطلاعاتی مانند خلاصه کوتاه از کار و اینکه چقدر در انجام آن پیش رفته‌اند، می‌شود. این داده‌ها در یک پایگاه داده ذخیره می‌شوند. سپس، آن‌ها می‌توانند در طول زمان یادداشت‌هایی در مورد پیشرفت خود در وظیفه بنویسند و در نهایت یادداشت کنند که کار را به پایان رسانده‌اند.
یک فیلد به نام "وضعیت" وجود دارد که نشان می‌دهد کاربر در انجام وظیفه چقدر پیشرفت کرده است. مقادیر این فیلد عبارت‌اند از: "شروع نشده"، "در حال پیشرفت"، "متوقف شده"، و "کامل". وقتی مقدار فیلد وضعیت "شروع نشده" است، فقط می‌تواند به "در حال پیشرفت" تغییر کند. وقتی وضعیت "در حال پیشرفت" است، می‌تواند به "متوقف شده" یا "کامل" تغییر کند. و وقتی "کامل" است، فقط می‌تواند به "در حال پیشرفت" برگردد.
در این برنامه ۱۰ فیلد دیگر با قوانین مشابه وجود دارد. هر یک از آن‌ها شامل اطلاعات متفاوتی درباره وظیفه هستند (برای مثال، اینکه وظیفه به چه کسی محول شده است، مهلت آن چیست، و غیره).
برای پیاده‌سازی این قوانین، توسعه‌دهنده یک قطعه کد بسیار طولانی و پیوسته می‌نویسد که هیچ ساختاری ندارد و همه آن در یک فایل است. او هر فیلد را با کدی سفارشی که خاص آن فیلد است، اعتبارسنجی می‌کند. برای مثال، هر بار که نیاز به بررسی وضعیت "کامل" دارد، کلمه "کامل" را به‌صورت مستقیم در کد می‌نویسد. همچنین، کد به شکلی نوشته نشده که قابل استفاده مجدد باشد. جایی که برنامه فیلدهای مشابه دارد، توسعه‌دهنده کد را کپی و پیست می‌کند و سپس آن را کمی برای فیلد جدید تغییر می‌دهد.
کد کار می‌کند. فایل ۳,۰۰۰ خط طول دارد. تقریباً هیچ طراحی‌ای ندارد.
چند ماه بعد، این توسعه‌دهنده پروژه را ترک می‌کند.
یک توسعه‌دهنده جدید می‌آید و مأموریت نگهداری این پروژه به او محول می‌شود. او به‌سرعت متوجه می‌شود که تغییر این کد دشوار است—اگر یک بخش را تغییر دهد، باید بسیاری از بخش‌های دیگر را به همان شکل تغییر دهد تا سیستم همچنان کار کند. اوضاع وقتی بدتر می‌شود که بخش‌های مختلف منطق بدون هیچ توضیح یا سیستم منطقی پراکنده شده‌اند—هر بار که می‌خواهید تغییری ایجاد کنید، باید تمام فایل را بخوانید.
مشتریان شروع به درخواست ویژگی‌های جدید می‌کنند. در ابتدا، توسعه‌دهنده جدید تمام تلاش خود را برای پیاده‌سازی این ویژگی‌های جدید می‌کند. او کد بیشتری به این فایل اضافه می‌کند. فایل در نهایت به ۵,۰۰۰ خط می‌رسد.
در نهایت، مشتریان شروع به درخواست ویژگی‌هایی می‌کنند که با این طراحی اصلاً قابل پیاده‌سازی نیست. آن‌ها می‌خواهند اطلاعات مربوط به وظایف را از طریق ایمیل ارسال کنند، اما این کد فقط از طریق فرم کار می‌کند. تمام کد به‌طور خاص بر اساس نحوه کار فرم طراحی شده است—هرگز با ایمیل کار نخواهد کرد.
رقبایی ظاهر می‌شوند که می‌توانند وظایف را از طریق ایمیل به‌روز کنند. پروژه شروع به از دست دادن مشتریان خود می‌کند.
تنها دلیلی که این پروژه زنده می‌ماند این است که دو توسعه‌دهنده یک سال کامل را صرف بازطراحی همین فایل می‌کنند تا تغییر دادن آن آسان شود. آن‌ها تمام تلاش خود را می‌کنند تا هم‌زمان با بازطراحی، به درخواست‌های ویژگی‌های جدید هم رسیدگی کنند، اما بیشتر وقتشان صرف بازطراحی می‌شود.

قانونی که برای جلوگیری از طراحی سفت و سخت استفاده می‌شود این است که: 
کد باید بر اساس آنچه اکنون می‌دانید طراحی شود، نه بر اساس آنچه فکر می‌کنید در آینده اتفاق خواهد افتاد.
طراحی را فقط بر اساس نیازهای فوری و شناخته‌شده خود انجام دهید، بدون اینکه امکان نیازهای آینده را نادیده بگیرید. اگر به‌طور قطع می‌دانید که سیستم شما باید کار X را انجام دهد، و فقط X، آن را فعلاً فقط برای انجام X طراحی کنید. ممکن است در آینده کارهای دیگری غیر از X انجام دهد، و باید این موضوع را در ذهن داشته باشید، اما فعلاً سیستم فقط باید X را انجام دهد.

هنگام طراحی به این شکل، همچنین بهتر است که تغییرات را کوچک نگه دارید. وقتی هدف فقط ایجاد یک تغییر کوچک است، به‌راحتی می‌توانید روی طراحی آن فکر کنید.
این به این معنا نیست که برنامه‌ریزی چیز بدی است. مقداری برنامه‌ریزی در طراحی نرم‌افزار بسیار ارزشمند است. اما حتی اگر برنامه‌های مفصلی ننویسید، تا زمانی که تغییرات شما همیشه کوچک باشد و کد شما به‌راحتی برای آینده‌ای ناشناخته قابل تطبیق باشد، مشکلی نخواهید داشت.
بیش از حد عمومی کردن
برخی توسعه‌دهندگان، که با این واقعیت مواجه شده‌اند که کدهایشان در آینده تغییر خواهد کرد،  سعی می‌کنند هنگام طراحی به یک راه‌حل بسیار عمومی دست پیدا کنند. زیرا به نظر خودشان در اینصورت آنها برای هر موقعیت احتمالی آینده آماده خواهد بود و با این مشکل مواجه نخواهند شد. ما به این حالت "بیش از حد مهندسی کردن" می‌گوییم.
فرهنگ لغت، "بیش‌ازحد مهندسی کردن" را ترکیبی از over (به معنای "خیلی زیاد") و engineer (به معنای "طراحی و ساخت") تعریف می‌کند. بنابراین، طبق فرهنگ لغت، به معنای طراحی یا ساختن چیزی است که برای موقعیت شما بیش از حد است.
صبر کنید—طراحی یا ساختن بیش از حد؟ "بیش از حد" یعنی چه؟ آیا طراحی چیز خوبی نیست؟
خب، بله، بیشتر پروژه‌ها می‌توانند از طراحی بیشتری استفاده کنند، همان‌طور که در "مثال: کدی بدون طراحی کافی" در بخش قبل دیدیم. اما گاهی اوقات، کسی واقعاً زیادی به آن وارد می‌شود و به‌طور افراطی پیش می‌رود—مثل این است که یک اسلحه لیزری بزرگ خارج از مدار زمین بسازید تا یک تپه مورچه را نابود کنید. طراحی این اسلحه عظیم یک شاهکار مهندسی شگفت‌انگیز است، اما هزینه بسیار زیادی دارد، ساخت آن خیلی طول می‌کشد، و یک کابوس برای نگهداری است. تصور کنید اگر خراب شد، مجبور باشید بروید آن را تعمیر کنید!
چندین مشکل دیگر نیز با بیش‌ازحد مهندسی کردن وجود دارد:

شما نمی‌توانید آینده را پیش‌بینی کنید، بنابراین مهم نیست که راه‌حل شما چقدر عمومی باشد، هرگز به اندازه کافی عمومی نخواهد بود که نیازهای واقعی آینده شما را برآورده کند.
وقتی کد شما بیش از حد عمومی باشد، اغلب از دیدگاه کاربر، نمی‌تواند به‌خوبی به جزئیات بپردازد. به‌عنوان‌مثال، فرض کنید کدی طراحی کرده‌اید که با تمام ورودی‌ها به یک شکل رفتار می‌کند—همه آن‌ها فقط بایت هستند. گاهی این کد متن پردازش می‌کند و گاهی تصاویر، اما تنها چیزی که می‌داند این است که بایت‌ها را دریافت می‌کند. از یک نظر، این طراحی خوبی است: کد ساده، خودکفا، کوچک و غیره است.
اما سپس مطمئن می‌شوید که هیچ بخشی از کد شما بین تصاویر و متن تفاوتی قائل نمی‌شود. این دیگر بیش از حد عمومی شده است. وقتی کاربر یک تصویر بد وارد می‌کند، خطایی که دریافت می‌کند این است: "شما بایت‌های بدی وارد کرده‌اید." درحالی‌که باید می‌گفت: "شما یک تصویر بد وارد کرده‌اید"، اما کد شما آن‌قدر عمومی است که نمی‌تواند این را به کاربر بگوید. (روش‌های زیادی وجود دارد که کد عمومی وقتی برای کاربردهای خاص استفاده می‌شود، به مشکل برمی‌خورد؛ این فقط یک مثال است.)
عمومی کردن بیش از حد به نوشتن کد زیادی که به آن نیازی نیست منجر می‌شود، که ما را به اشتباه رایج اولمان (نوشتن کدی که نیاز نیست) بازمی‌گرداند.
به‌طورکلی، وقتی طراحی شما چیزها را پیچیده‌تر می‌کند به‌جای اینکه آن‌ها را ساده‌تر کند، در حال بیش‌ازحد مهندسی کردن هستید. آن اسلحه لیزری زندگی کسی را که فقط نیاز دارد چند تپه مورچه را نابود کند به‌شدت پیچیده می‌کند، درحالی‌که مقداری سم ساده مورچه زندگی آن شخص را بسیار ساده می‌کند و مشکل مورچه‌ها را حل می‌کند.
عمومی کردن چیزهای درست، به روش‌های درست، می‌تواند اساس یک طراحی نرم‌افزاری موفق باشد. بااین‌حال، عمومی کردن بیش از حد می‌تواند باعث پیچیدگی، سردرگمی و تلاش‌های نگهداری زیاد شود. قانون جلوگیری از این نقص مشابه قانون جلوگیری از طراحی‌های سفت و سخت است:
به اندازه‌ای عمومی باشید که همین الآن می‌دانید باید باشید.


مثال: بیش از حد عمومی کردن
در بخشی از یک برنامه، کاربر فرمی را پر می‌کرد و برنامه صدها ایمیل ارسال می‌کرد. این بخش از برنامه بسیار کند بود. کاربر فرم را ارسال می‌کرد و برنامه برای مدت طولانی در حال ارسال همه پیام‌ها بود.
برای سریع‌تر کردن این فرایند، توسعه‌دهندگان تصمیم گرفتند که همه ایمیل‌ها را فوراً ارسال نکنند. در عوض، آن‌ها در پس‌زمینه، پس از ارسال فرم توسط کاربر، از یک قطعه کد موجود به نام "Email Sender" استفاده می‌کردند.
توسعه‌دهنده‌ای که شروع به کار روی این تغییر کرد، تصمیم گرفت که ممکن است برخی شرکت‌ها بخواهند از چیزی به‌جز فرستنده ایمیل استفاده کنند. او صدها خط کد نوشت تا به مشتریان این امکان را بدهد که افزونه‌هایی (plug in) بنویسند تا سیستم‌های دیگر را برای انجام این کارهای پس‌زمینه استفاده کنند. هیچ‌یک از مشتریان هرگز چنین درخواستی نکرده بودند؛ توسعه‌دهنده فقط پیش‌بینی کرد که کسی در آینده این نوع انعطاف‌پذیری را خواهد خواست.
در نهایت، معمار ارشد برنامه مسئولیت این تغییر را بر عهده گرفت. او تمام کد مربوط به "پلاگین کردن" سیستم‌های دیگر را حذف کرد، زیرا هیچ مدرکی وجود نداشت که کاربران آن را بخواهند. بنابراین، هیچ مدرکی وجود نداشت که کد باید در این لحظه به این اندازه عمومی باشد. با حذف آن بخش‌ها، تغییرات بسیار ساده‌تر شد.
چهار سال از زمانی که این تغییر انجام شد می‌گذرد و هنوز هیچ مشتری به امکان پلاگین کردن سیستم‌های دیگر نیازی نداشته است. در واقع، هیچ دلیلی برای عمومی بودن کد به آن اندازه وجود نداشت.

توسعه و طراحی تدریجی
یک روش توسعه نرم‌افزار وجود دارد که به‌طور ذاتی از این سه اشتباه رایج اجتناب می‌کند. این روش "توسعه و طراحی تدریجی" نامیده می‌شود. این روش شامل طراحی و ساخت سیستم قطعه‌به‌قطعه و به ترتیب است.
این روش را می‌توان به‌سادگی با یک مثال توضیح داد. در اینجا نحوه استفاده از آن برای توسعه یک برنامه ماشین‌حساب که نیاز به جمع، تفریق، ضرب و تقسیم دارد، آمده است:
یک سیستم را برنامه‌ریزی کنید که فقط جمع انجام می‌دهد و هیچ چیز دیگر.
آن سیستم را پیاده‌سازی کنید.
طراحی سیستم موجود را اصلاح کنید تا اضافه کردن ویژگی تفریق آسان شود.
ویژگی تفریق را در سیستم پیاده‌سازی کنید. اکنون سیستمی داریم که فقط جمع و تفریق انجام می‌دهد و هیچ چیز دیگر.
دوباره طراحی سیستم را اصلاح کنید تا اضافه کردن ویژگی ضرب آسان شود.
ویژگی ضرب را در سیستم پیاده‌سازی کنید. اکنون سیستمی داریم که جمع، تفریق، ضرب انجام می‌دهد و هیچ چیز دیگر.
دوباره طراحی سیستم را اصلاح کنید تا اضافه کردن ویژگی تقسیم آسان شود. (در این مرحله، این کار باید کم یا بدون تلاش انجام شود، زیرا ما قبلاً طراحی را قبل از پیاده‌سازی تفریق و ضرب بهبود داده‌ایم.)
ویژگی تقسیم را در سیستم پیاده‌سازی کنید. اکنون سیستمی داریم که ما از ابتدا قصد داشتیم بسازیم، با طراحی عالی که کاملاً مناسب آن است.
این روش توسعه نیاز به زمان و تفکر کمتری نسبت به برنامه‌ریزی کل سیستم از ابتدا و ساخت آن به‌یکباره دارد. ممکن است اگر به روش‌های دیگر توسعه عادت کرده باشید، ابتدا آسان نباشد، اما با تمرین آسان خواهد شد.
بخش دشوار استفاده از این روش، تصمیم‌گیری در مورد ترتیب پیاده‌سازی است. به‌طورکلی، در هر مرحله باید ساده‌ترین کاری که می‌توانید انجام دهید را انتخاب کنید. ما ابتدا جمع را انتخاب کردیم زیرا ساده‌ترین عملیات از بین چهار عملیات بود و سپس تفریق را انتخاب کردیم زیرا به‌طور منطقی بر اساس جمع ساخته شده بود و بسیار ساده بود. ممکن بود ضرب را به‌عنوان عملیات دوم انتخاب کنیم، زیرا ضرب فقط تکرار چندباره عمل جمع است. تنها چیزی که به‌عنوان دومین مرحله انتخاب نمی‌کردیم تقسیم بود، زیرا انتقال از جمع به تقسیم یک جهش منطقی بزرگ است—بیش از حد پیچیده است. از سوی دیگر، انتقال از ضرب به تقسیم در پایان واقعاً بسیار ساده بود، بنابراین انتخاب خوبی بود.
گاهی حتی ممکن است نیاز باشد که یک ویژگی را به مراحل کوچک، ساده و منطقی تقسیم کنید تا بتوانید به‌راحتی آن را پیاده‌سازی کنید.
در واقع، این روش ترکیبی از دو روش است: یکی "توسعه تدریجی" و دیگری "طراحی تدریجی." توسعه تدریجی یک روش برای ساختن یک سیستم کامل است که کارها را به قطعات کوچک تقسیم می‌کند. در لیست ما، هر مرحله که با "پیاده‌سازی" شروع می‌شد، بخشی از فرایند توسعه تدریجی بود. طراحی تدریجی نیز به همین ترتیب روشی برای ایجاد و بهبود طراحی سیستم به‌صورت تدریجی است. هر مرحله که با "اصلاح طراحی سیستم" یا "برنامه‌ریزی" شروع می‌شد، بخشی از فرایند طراحی تدریجی بود.
توسعه و طراحی تدریجی تنها روش معتبر توسعه نرم‌افزار نیست، اما قطعاً روشی است که از سه اشتباه رایج بیان‌شده در بخش قبلی جلوگیری می‌کند.
