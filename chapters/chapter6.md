# فصل ۶ سادگی

خب، اگر هیچ‌گاه نرم‌افزار خود را تغییر ندهیم، می‌توانیم به‌طور کامل از ایجاد عیوب جلوگیری کنیم. 
اما تغییر اجتناب‌ناپذیر است، به‌ویژه اگر قرار باشد ویژگی‌های جدیدی اضافه کنیم. 
بنابراین "هیچ چیز را تغییر ندهید" نمی‌تواند تکنیک نهایی برای کاهش عیوب باشد.

همان‌طور که در فصل ۵ توضیح داده شد، اگر می‌خواهید از ایجاد عیوب در کد خود جلوگیری کنید، اینکه تغییرات خود را کوچک نگه دارید سودمند خواهد بود. 
اما اگر می‌خواهید حتی از تغییرات کوچک هم عیوب را حذف کنید، قانون دیگری وجود دارد که می‌تواند به شما کمک کند. 
و این قانون فقط عیوب را کاهش نمی‌دهد—بلکه نگهداری کد را آسان می‌کند، اضافه کردن ویژگی‌های جدید را ساده می‌کند و درک کلی کد شما را بهبود می‌بخشد. 
این قانون سادگی است:

**سهولت نگهداری هر قطعه نرم‌افزار متناسب با سادگی قطعات آن است.**

یعنی، هرچه قطعات ساده‌تر باشند، راحت‌تر می‌توانید در آینده آن‌ها را تغییر دهید. 
دستیابی به سهولت کامل در نگهداری غیرممکن است، اما این هدفی است که باید برای آن تلاش کنید—تغییر کامل یا اضافه کردن بی‌نهایت کد جدید بدون هیچ مشکلی.

شاید متوجه شده باشید که این قانون درباره سادگی کل سیستم صحبت نمی‌کند، بلکه فقط درباره قطعات آن است. 
چرا؟

خب، یک برنامه کامپیوتری با اندازه متوسط آن‌قدر پیچیده است که هیچ انسانی نمی‌تواند تمام آن را یک‌باره درک کند. 
تنها امکان درک قطعات آن وجود دارد. 
بنابراین، همیشه با یک ساختار بزرگ و پیچیده برای کل برنامه مواجه هستیم. 
آنچه مهم می‌شود این است که قطعات برنامه وقتی به آن‌ها نگاه می‌کنیم قابل درک باشند. 
هرچه قطعات ساده‌تر باشند، احتمال بیشتری وجود دارد که هر فرد آن‌ها را بفهمد. 
این به‌ویژه زمانی مهم است که کد خود را به دیگران تحویل می‌دهید، یا وقتی بعد از چند ماه از کد دور بوده‌اید و مجبورید دوباره به آن برگردید و آنچه را که انجام داده‌اید، یاد بگیرید.

> [!NOTE]
> 
> **یک تشبیه معماری**
> 
> تصور کنید که در حال ساختن یک سازه فولادی ۳۰ فوتی هستید.
> می‌توانید آن را از چندین تیر کوچک بسازید که قطعات ساده‌ای هستند.
> یا می‌توانید سه قطعه بزرگ و پیچیده از فولاد بسازید و آن‌ها را کنار هم قرار دهید.
> 
> با روش تیرهای کوچک، ساختن یا خریدن قطعات جداگانه آسان است.
> و اگر یکی از آن‌ها بشکند، فقط آن را با یک قطعه یدکی مشابه جایگزین می‌کنید.
> ساخت و ساز ساده است و نگهداری هم به همین ترتیب آسان است.
> 
> اما سه قطعه بزرگ باید با دقت سفارشی ساخته شوند و به‌طور گسترده‌ای روی آن‌ها کار شود.
> هر قطعه تمام‌شده آن‌قدر بزرگ است که پیدا کردن و رفع همه عیوب آن دشوار است.
> و اگر پس از اتمام ساختمان، متوجه تعداد زیادی نقص در هر قطعه شوید، نمی‌توانید آن‌ها را جایگزین کنید—اگر یکی از قطعات را بیرون بیاورید، ساختمان فرو می‌ریزد.
> بنابراین، مجبورید تکه‌های زشت فلزی را جوش دهید و امیدوار باشید که کل سازه پایدار بماند.
> 
> نرم‌افزار بسیار شبیه به این است—وقتی کد خود را به قطعات ساده و خودکفا تقسیم می‌کنید، رفع عیوب و نگهداری سیستم آسان است.
> اما وقتی کد خود را به قطعات بزرگ و پیچیده تقسیم می‌کنید، هر قطعه نیاز به کار زیادی دارد و به‌اندازه کافی اصلاح نمی‌شود.
> سیستم نگهداری سخت می‌شود و باید به‌طور مداوم اصلاحات و میانبرهایی به آن اضافه شود تا به کار خود ادامه دهد.
> 
> پس چرا گاهی اوقات مردم نرم‌افزار را به‌صورت قطعات بزرگ و پیچیده می‌نویسند به‌جای قطعات کوچک و ساده؟
> خب، در هنگام ایجاد نرم‌افزار، یک صرفه‌جویی زمانی دیده می‌شود که با روش قطعات بزرگ همراه است.
> با قطعات کوچک، زمان زیادی صرف قرار دادن آن‌ها کنار هم می‌شود.
> شما این مشکل را با قطعات بزرگ نمی‌بینید—تعداد کمی از آن‌ها وجود دارد، کنار هم قرار می‌گیرند و تمام.
> 
> با این حال، کیفیت سیستم قطعات بزرگ بسیار پایین‌تر است، و در آینده زمان زیادی را صرف رفع آن خواهید کرد.
> نگهداری آن سخت‌تر و سخت‌تر می‌شود، درحالی‌که در یک سیستم ساده نگهداری آسان و آسان‌تر می‌شود.
> در بلندمدت، این سادگی است که کارآمد است، نه پیچیدگی.

پس چگونه می‌توانیم از این قانون در دنیای‌ برنامه‌نویسی استفاده کنیم؟ 
این موضوع بخش بزرگی از ادامه این کتاب است. 
اما به‌طور کلی، ایده این است که اجزای کد خود را تا حد ممکن ساده کنید و سپس مطمئن شوید که این سادگی با گذشت زمان حفظ می‌شود.

یکی از راه‌های خوب برای انجام این کار استفاده از روش توسعه و طراحی تدریجی است که در پایان فصل ۴ معرفی شد. 
از آنجا که یک مرحله "بازطراحی" قبل از اضافه کردن هر ویژگی جدید وجود دارد، می‌توانید از آن زمان برای ساده‌سازی سیستم استفاده کنید. 
حتی اگر از آن روش استفاده نمی‌کنید، می‌توانید بین اضافه کردن ویژگی‌ها مدتی وقت بگذارید تا هر قطعه‌ای که برای شما یا سایر توسعه‌دهندگان پیچیده به نظر می‌رسد را ساده کنید.

به‌هر شکلی، شما غالبا مجبور خواهید شد که آنچه را که ساخته‌اید ساده‌تر کنید—نمی‌توانید به این تکیه کنید که طراحی اولیه شما همیشه درست باشد. 
شما باید قطعات سیستم را به‌طور مداوم بازطراحی کنید، زیرا موقعیت‌ها و نیازهای جدید پیش می‌آیند.

البته، این می‌تواند کار نسبتاً دشواری باشد. 
شما برای نوشتن برنامه‌های خود با ابزارهای ساده‌ای سروکار ندارید—زبان‌های برنامه‌نویسی پیچیده هستند، خود کامپیوتر پیچیده است، و غیره. 
اما برای سادگی تلاش کنید، با هر آنچه در اختیار دارید.

## سادگی و معادله طراحی نرم‌افزار

این قانون به مهم‌ترین چیزی اشاره می‌کند که می‌توانیم در زمان حال انجام دهیم تا تلاش نگهداری را در معادله طراحی نرم‌افزار کاهش دهیم—کد خود را ساده‌تر کنیم. 
برای این کار نیازی به پیش‌بینی آینده نداریم؛ فقط می‌توانیم به کد خود نگاه کنیم، ببینیم که آیا پیچیده است و پیچیدگی آن را همین حالا برای خودمان کمتر کنیم. 
این همان راهی است که تلاش نگهداری شما را با گذشت زمان کاهش می‌دهد—شما به‌طور مداوم کد خود را ساده‌تر می‌کنید.

بدیهی است که ساده کردن و ساده نگه داشتن کد نیاز به تلاش دارد، اما به‌طور کلی ایجاد تغییرات در یک سیستم ساده نسبت به یک سیستم پیچیده بسیار آسان‌تر است—پس شما الان کمی زمان صرف ساده‌سازی می‌کنید تا بعداً زمان زیادی را ذخیره کنید.

وقتی تلاش نگهداری سیستم خود را کاهش می‌دهید، مطلوبیت تمام تغییرات احتمالی دیگر را افزایش می‌دهید. 
با توجه به معادله طراحی نرم‌افزار (در فصل ۳ توضیح داده شده است)، ساده‌سازی کد هزینه نگهداری را کم می‌کند و در نتیجه مطلوبیت هر تغییر احتمالی افزایش می‌یابد.

## سادگی نسبی است

خب، ما می‌خواهیم چیزها ساده باشند. 
اما اینکه چگونه "ساده" را تعریف می‌کنید واقعاً بستگی به مخاطب شما دارد. 
چیزی که برای شما ساده است، ممکن است برای همکارانتان ساده نباشد. 
همچنین، وقتی چیزی را ایجاد می‌کنید، ممکن است از نظر شما نسبتاً "ساده" به نظر برسد، زیرا شما آن را از درون و بیرون می‌شناسید. 
اما برای کسی که هرگز آن را ندیده است، ممکن است بسیار پیچیده به نظر برسد.

اگر می‌خواهید دیدگاه کسی را که هیچ چیزی درباره کد شما نمی‌داند درک کنید، کدی را پیدا کنید که هرگز نخوانده‌اید و آن را بخوانید. 
سعی کنید نه فقط تک تک خطوط، بلکه کل برنامه را بفهمید و ببینید اگر مجبور بودید آن را تغییر دهید، چگونه آن را تغییر می‌دادید. 
این همان تجربه‌ای است که دیگران هنگام خواندن کد شما دارند. 
ممکن است خواندن کد دیگران برای شما خسته‌کننده باشد حتی اگر پیچیدگی خیلی بالا هم نداشته باشد.

به همین دلیل خوب است که در مستندات کد خود بخش‌هایی مانند "آیا این کد را اولین بار است که می‌خوانید؟" داشته باشید که شامل توضیحات ساده‌ای است که به افراد در درک کد شما کمک می‌کند. 
این توضیحات باید به‌گونه‌ای نوشته شوند که انگار خواننده هیچ چیزی درباره برنامه نمی‌داند، زیرا اگر افراد در کاری جدید باشند، احتمالاً چیزی درباره آن نمی‌دانند.

بسیاری از پروژه‌های نرم‌افزاری این موضوع را به اشتباه انجام می‌دهند. 
وقتی می‌خواهید مستندات نوشته‌شده برای توسعه‌دهندگان را بخوانید، با انبوهی از لینک‌ها فاقد خط سیر مشخصی مواجه می‌شوید. 
این از نظر توسعه‌دهنده قدیمی پروژه ساده به نظر می‌رسد، زیرا یک صفحه با تعداد زیادی لینک به او اجازه می‌دهد به‌سرعت به قسمتی که به‌دنبال آن است، دسترسی پیدا کند. 
اما برای کسی که تازه وارد پروژه شده، این پیچیده است. 
از طرف دیگر، برای توسعه‌دهنده قدیمی، اضافه کردن توضیحات دیگر به مستندات و حذف آن لیست لینک‌ها غیرضروری به نظر می‌آید و به پیچیدگی کار او اضافه می‌کند، زیرا هدف اصلی او فقط یافتن یک چیز بسیار خاص در مستندات است.

تنها چیزی که از مستندات پیچیده بدتر است، مستندات نداشتن است. 
یعنی از شما انتظار می‌رود خودتان بفهمید یا "از قبل بدانید" که کد چگونه کار می‌کند. 
برای خود توسعه‌دهنده، نحوه کار برنامه وی آشکار است، اما برای دیگران کاملاً ناشناخته است.

علاوه بر مخاطب، زمینه نیز مهم است. 
برای مثال، در زمینه برنامه‌نویسی، استفاده از تکنولوژی‌های پیشرفته اغلب به سادگی منجر می‌شوند. 
اما تصور کنید که ساختار داخلی پیشرفته همین تکنولوژی پیشرفته را به‌طور مستقیم به‌عنوان تنها رابط برنامه در یک صفحه وب نمایش داده دهیم، آیا همین تکنولوژی پیشرفته در اینجا هم باعث سادگی می‌شود؟ 
استفاده از چنین رابط کاریری‌ای برای توسعه‌دهنده‌ها هم ساده نخواهد بود!

گاهی چیزی که در یک زمینه پیچیده به نظر می‌رسد، در زمینه‌ای دیگر ساده است. 
نمایش مقدار زیادی متن توضیحی بر روی یک بیلبورد کنار جاده بیش از حد پیچیده خواهد بود—هیچ وقت کافی برای رانندگان در حال عبور وجود ندارد تا تمام آن متن را بخوانند، بنابراین گذاشتن آن آنجا کار احمقانه‌ای خواهد بود. 
اما در یک دفترچه راهنمای برنامه کامپیوتری، برای توضیح دادن چیزی گنجاندن مقدار زیادی متن بسیار ساده‌تر از ارائه یک توضیح یک‌جمله‌ای است. 
به همین دلیل در چنین کتاب‌هایی هیچ‌گاه فصل‌هایی با یک خط وجود ندارد؛ گفتن چیزی بدون توضیح دادن آن واقعاً ساده نخواهد بود.

با در نظر گرفتن تمام این دیدگاه‌ها و زمینه‌های مختلف، آیا این به این معنی است که دستیابی به سادگی بسیار دشوار است؟ 
نه! اصلاً. 
برای هر چیزی مخاطبان خاصی وجود دارند و زمینه هر کاری که انجام می‌دهید معمولاً بسیار محدود است. 
مشکل همیشه قابل‌حل است. 
فقط مهم است که این موارد را هنگام طراحی نرم‌افزار خود در نظر بگیرید، تا وقتی کسی واقعاً به سراغ استفاده از آن می‌آید، برای آن شخص خاص واقعاً ساده باشد.

> [!NOTE]
> **جنگ ویرایشگرها**
> 
> در دنیای توسعه نرم‌افزار، بحث‌های متعددی در مورد اینکه بهترین ابزار برای انجام یک کار چیست، وجود داشته است.
> مردم ویرایشگرهای متنی مختلف، زبان‌های برنامه‌نویسی مختلف، سیستم‌عامل‌های مختلف و غیره را دوست دارند.
> شاید مشهورترین "جنگ" در توسعه نرم‌افزار، بین کاربران دو ویرایشگر متنی خاص یعنی vi و Emacs باشد.
> کاربران هر یک گاهی ادعا می‌کنند که ویرایشگر موردعلاقه آن‌ها از نظر بنیادی بهتر از دیگری است.
> 
> در واقعیت، به‌ندرت ابزاری وجود دارد که از نظر اصولی برای نوشتن نرم‌افزار برتر باشد؛ فقط ابزاری وجود دارد که افراد خاص آن را برای کار موردنظر ساده‌تر می‌دانند.
> کاربران Emacs، این ویرایشگر را ساده‌ترین ابزار برای نوشتن نرم‌افزار می‌دانند و کاربران vi نیز vi را ساده‌ترین می‌دانند.
> تا حدی، این موضوع به تفاوت‌های بنیادی بین افراد در نحوه کار یا تفکر آن‌ها بستگی دارد.
> مردم به‌سادگی ترجیحات مختلفی دارند و هیچ درست یا غلطی وجود ندارد.
> اما در سطح گسترده‌تر، سادگی درک‌شده یک ابزار بیشتر به آشنایی با آن بستگی دارد—کسی که از ابزاری خاص برای مدت طولانی استفاده کرده است، احتمالاً به آن بسیار آشنا شده و آن را بسیار ساده‌تر از هر ابزار دیگری می‌داند.
> برای اینکه یک ابزار جدید به همان اندازه ساده به نظر برسد، آن ابزار باید فوق‌العاده ساده باشد، و ویرایشگرهای متنی برنامه‌نویسان به‌ندرت چنین هستند.
> 
> احتمالاً غیر برنامه‌نویسان هر دو ویرایشگر را بسیار پیچیده و فراتر از منطق بدانند، که این مثال دیگری از نسبی بودن سادگی است.
> 
> > [!TIP]
> > 
> > ابزارها ممکن است مشکلاتی داشته باشند که آن‌ها را برای کار مناسب نکند یا به دلایل طراحی نرم‌افزار گزینه اشتباهی باشند (به "تکنولوژی‌های بد" در فصل ۷ مراجعه کنید).
> > اما در نبود چنین مشکلاتی، سادگی نسبی یک ابزار است که به یک برنامه‌نویس اجازه می‌دهد تعیین کند که چه چیزی برای یک موقعیت خاص بهترین است.

## چقدر باید ساده باشیم؟

وقتی روی یک پروژه کار می‌کنید، ممکن است سوالاتی در مورد سادگی به وجود بیاید. 
چقدر واقعاً باید ساده باشیم؟ 
تا چه حد باید این چیز را ساده کنیم؟ 
آیا به‌اندازه کافی ساده است؟

خب، البته سادگی نسبی است. 
اما حتی با این حال، شما همچنان می‌توانید بیشتر یا کمتر ساده‌سازی کنید. 
از دیدگاه نسبی کاربر شما، محصول شما ممکن است سخت، آسان یا چیزی بین این دو برای استفاده باشد. 
به همین ترتیب، از دیدگاه یک برنامه‌نویس دیگر، کد شما می‌تواند نسبتاً سخت یا آسان برای خواندن باشد.

بنابراین، چقدر باید ساده باشید؟

صادقانه؟

اگر واقعاً می‌خواهید موفق شوید؟

باید خیلی، خیلی ساده باشید.

نکته خوب در مورد این سطح از سادگی این است که در بیشتر موارد، هر چیزی که برای افراد عادی قابل استفاده باشد، برای نابغه‌ها نیز قابل استفاده است. 
شما دامنه وسیع‌تری از کاربران بالقوه خواهید داشت.

اما اغلب مردم واقعاً نمی‌فهمند که چقدر باید ساده و واضح باشند تا به آن سطح برسند. 
بیایید یک مثال بزنیم. 
وقتی در یک مرکز خرید هستید، نقشه‌هایی وجود دارد که به شما می‌گوید هر چیزی کجاست. 
در بهترین نقشه‌های مراکز خرید، یک نقطه قرمز بزرگ با کلمات "شما اینجا هستید" با حروف بسیار بزرگ درست در مقابل شما قرار دارد. 
در نقشه‌های ضعیف‌تر، یک مثلث زرد کوچک در وسط نقشه وجود دارد که پیدا کردن آن بسیار دشوار است، و در کناری متنی وجود دارد که توضیح می‌دهد: 
"مثلث زرد کوچک به معنای 'شما اینجا هستید!' است." 
با اضافه شدن این به سردرگمی عمومی برای پیدا کردن چیزی در این نقشه‌ها، ممکن است ۵ یا ۶ دقیقه فقط جلوی نقشه بایستید و سعی کنید بفهمید چطور به جایی که می‌خواهید بروید.

برای فردی که نقشه را طراحی کرده است، این ممکن است کاملاً منطقی به نظر برسد. 
او زمان زیادی را صرف طراحی آن کرده، بنابراین برای او واضح است که مهم است و احتمالاً خوشحال می‌شود چند دقیقه وقت صرف کند تا آن را یاد بگیرد. 
اما برای ما، افرادی که واقعاً از نقشه استفاده می‌کنیم، این یک بخش بسیار جزئی از زندگی ما است. 
ما فقط می‌خواهیم آن‌قدر ساده باشد که بتوانیم سریع از آن استفاده کنیم و به کار خود ادامه دهیم!

بسیاری از برنامه‌نویسان در این مورد با کد خود بسیار بد عمل می‌کنند. 
آن‌ها فرض می‌کنند که برنامه‌نویسان دیگر مایل هستند زمان زیادی صرف یادگیری کد آن‌ها کنند، زیرا به هر حال، نوشتن آن زمان زیادی برده است! 
این کد برای آن‌ها مهم است، پس آیا برای همه مهم نخواهد بود؟

خب، برنامه‌نویسان عموماً افراد باهوشی هستند. 
اما این هنوز اشتباه است که فکر کنید: 
"اوه، برنامه‌نویسان دیگر همه چیزهایی که اینجا انجام داده‌ام را بدون هیچ ساده‌سازی یا توضیحی در مورد کد من خواهند فهمید." 
این مسئله مربوط به هوش نیست—بلکه مربوط به دانش است. 
برنامه‌نویسانی که تازه با کد شما آشنا می‌شوند، هیچ چیز درباره آن نمی‌دانند؛ آن‌ها باید یاد بگیرند. 
هرچه یادگیری را برای آن‌ها آسان‌تر کنید، سریع‌تر آن را خواهند فهمید و استفاده از آن برایشان راحت‌تر خواهد بود.

روش‌های زیادی برای آسان کردن یادگیری کد شما وجود دارد: 
مستندات ساده، طراحی ساده، آموزش‌های مرحله‌به‌مرحله و غیره.
اما، اگر کد شما به طرز ساده و روشنی قابل یادگیری نباشد، مردم با آن مشکل خواهند داشت. 
آن‌ها به‌درستی از آن استفاده نمی‌کنند، باگ ایجاد می‌کنند و به‌طور کلی همه چیز را به هم می‌ریزند. 
و وقتی این همه اتفاق بیفتد، چه کسی را برای پرسیدن سوالات به سراغش می‌روند؟ 
بله، شما! شما باید وقت خود را صرف پاسخ به همه سوالات آن‌ها کنید. 
(به نظر سرگرم‌کننده می‌آید، نه؟)

هیچ‌کدام از ما دوست نداریم با ما مانند افراد نادان رفتار شود. 
و گاهی اوقات این ما را وادار می‌کند چیزهایی ایجاد کنیم که کمی پیچیده هستند، تا احساس نکنیم که کاربر یا برنامه‌نویسان دیگر را دست کم گرفته‌ایم. 
ما چند کلمه بزرگ اضافه می‌کنیم، آن را کمی کمتر از حد ساده می‌کنیم و مردم به هوش ما احترام می‌گذارند، اما احساس حماقت می‌کنند، زیرا آن را نمی‌فهمند. 
ممکن است فکر کنند ما خیلی باهوش‌تر از آن‌ها هستیم، و این به نوعی دلگرم‌کننده است. 
اما واقعاً، آیا این به آن‌ها کمک می‌کند؟

از طرف دیگر، وقتی محصول یا کد خود را به طرز احمقانه‌ای ساده می‌کنید، به مردم اجازه می‌دهید آن را درک کنند. 
این به آن‌ها احساس هوش می‌دهد، به آن‌ها اجازه می‌دهد کاری که قصد دارند انجام دهند را انجام دهند، و هیچ تأثیر منفی روی شما نمی‌گذارد. 
در واقع، احتمالاً مردم بیشتر شما را تحسین خواهند کرد اگر کارها را ساده کنید تا اینکه آن‌ها را پیچیده کنید.
البته، لازم نیست که کل خانواده شما بتوانند کد شما را بخوانند. 
سادگی همچنان نسبی است و مخاطب هدف برای کد، برنامه‌نویسان دیگر هستند. 
اما برای آن برنامه‌نویسان دیگر، کد شما باید بسیار ساده و آسان برای درک باشد. 
ممکن است به هر اندازه که لازم است از تکنولوژی‌های پیشرفته برای دستیابی به آن سادگی استفاده کنید، اما در نهایت باید همچنان ساده باشد.

وقتی سوال "چقدر باید ساده باشم؟" مطرح می‌شود، ممکن است از خود بپرسید: 
"آیا می‌خواهم مردم آن را بفهمند و خوشحال باشند، یا می‌خواهم آن‌ها گیج و ناامید شوند؟" 
اگر گزینه اول را انتخاب کنید، فقط یک سطح از سادگی وجود دارد که موفقیت شما را تضمین می‌کند: 
ساده و واضح.

## یکدست باشید

یکدستی بخش بزرگی از سادگی است. 
اگر جایی کاری را به یک شکل خاص انجام می‌دهید، آن کار را در همه جا به همان شکل انجام دهید.

اگر یک متغیر را به این صورت نام‌گذاری می‌کنید: 
`somethingLikeThis`
، پس همه متغیرهای شما باید به همین شکل نام‌گذاری شوند 
(
`otherVariable`
، 
`anotherNameLikeThat`،
و غیره).
اگر متغیرهایی دارید که به این شکل نام‌گذاری شده‌اند: 
`named_like_this`،
پس همه متغیرها باید به صورت حروف کوچک باشند و بین کلمات آن‌ها از زیرخط (underscore) استفاده شود.

کدی که یکدست نیست، فهم و خواندن آن برای برنامه‌نویسان سخت‌تر است.

می‌توانیم این موضوع را با مثالی از زبان طبیعی نشان دهیم. 
این دو جمله را مقایسه کنید:

- This is a normal sentence with normal words that everybody can understand.
- tHisisanOrmalseNtencewitHnorMalwordsthAtevErybOdycAnunderStaNd.

هر دوی این جملات دقیقاً یک معنی دارند، اما جمله اول به دلیل یکدستی با نحوه نوشتن معمول انگلیسی بسیار ساده‌تر است. 
البته که خواندن جمله دوم ممکن است، اما آیا دوست دارید یک کتاب کامل به این شکل بخوانید؟ 
اگر نه، آیا دوست دارید کد کامل یک برنامه را بخوانید درحالیکه  غیر یکدست نوشته شده است؟

در برنامه‌نویسی، موقعیت‌هایی وجود دارد که مهم نیست چگونه کاری را انجام می‌دهید، به شرطی که همیشه به همان شکل انجام دهید. 
به‌طور نظری، می‌توانید کد خود را به شکلی بسیار پیچیده بنویسید، اما تا زمانی که در آن یکدست باشید، مردم یاد می‌گیرند چگونه آن را بخوانند. 
(البته بهتر است که هم یکدست باشید و هم ساده، اما اگر نمی‌توانید کاملاً ساده باشید، حداقل یکدست باشید.)

یکدستی کامل در بسیاری از موارد می‌تواند برنامه‌نویسی را آسان‌تر کند. 
برای مثال، اگر هر شیء در برنامه شما یک فیلد به نام `name` داشته باشد، می‌توانید یک قطعه کد ساده بنویسید که با فیلد `name` هر شیء در کل برنامه شما سروکار دارد. 
اما اگر در Object A فیلد `name` به نام `a_name` باشد و در Object B به نام `name_of_mine` باشد، باید کد خاصی برای سروکار داشتن با Object A و Object B به‌طور متفاوت بنویسید.

به همین ترتیب، برنامه شما باید به‌صورت داخلی به شکلی یکدست رفتار کند. 
یک برنامه‌نویس که با نحوه استفاده از یک بخش کد شما آشناست، باید فوراً با نحوه استفاده از بخش دیگری از کد شما آشنا شود، زیرا هر دو بخش به روشی مشابه عمل می‌کنند. 
برای مثال، اگر هنگام استفاده از بخش A، برنامه‌نویس باید سه تابع را فراخوانی کند و سپس کدی بنویسد، هنگام استفاده از بخش B نیز باید مجموعه مشابهی از سه تابع را فراخوانی کرده و سپس کدی بنویسد. 
و اگر شما یک تابع به نام dump در بخش A دارید که باعث می‌شود بخش A تمام متغیرهای داخلی خود را چاپ کند، تابع dump در بخش B نیز باید همان کار را برای بخش B انجام دهد. 
نگذارید برنامه‌نویسان مجبور شوند هر بار که به بخش جدیدی از سیستم شما نگاه می‌کنند، نحوه کار سیستم را دوباره یاد بگیرند.

شاید در دنیای واقعی این‌قدر یکدستی وجود نداشته باشد، اما شما مسئول دنیای برنامه خود هستید، بنابراین می‌توانید چیزها را ساده و یکدست کنید.

در دنیای واقعی هم نمونه‌هایی از یکدستی وجود دارد. 
در بخش بزرگی از آسیا، مردم از چاپستیک‌ها برای غذا خوردن استفاده می‌کنند. 
در قاره‌های آمریکا و اروپا، مردم از چنگال استفاده می‌کنند. 
خب، این دو روش مختلف غذا خوردن است، اما به‌طور کلی در هر منطقه کاملاً یکدست است. 
حالا تصور کنید که هر بار که به خانه کسی می‌رفتید، باید یک روش جدید برای غذا خوردن یاد می‌گرفتید. 
شاید در خانه Bob با قیچی غذا بخورند و در خانه Mary با تکه‌های مقوای صاف. 
خوردن بسیار پیچیده می‌شد، نه؟

همین موضوع در برنامه‌نویسی هم صادق است—بدون یکدستی، همه چیز پیچیده می‌شود. 
با یکدستی، همه چیز ساده می‌شود. 
و حتی اگر ساده نباشند، حداقل فقط یک‌بار پیچیدگی را یاد می‌گیرید و بعد همیشه آن را می‌دانید.

## خوانایی

همان‌طور که بارها در دنیای توسعه نرم‌افزار گفته شده است، کد بیشتر خوانده می‌شود تا نوشته شود. 
بنابراین، مهم است که کد به‌راحتی قابل خواندن باشد:

**خوانایی کد عمدتاً به نحوه استفاده از فضا توسط حروف و نمادها بستگی دارد.**

اگر تمام جهان سیاه بود، شما نمی‌توانستید اشیا را از هم جدا کنید. 
همه آن‌ها یک توده سیاه می‌بودند. 
به همین ترتیب، اگر یک فایل توده‌ای از کد باشد بدون فاصله‌های کافی و منظم، تشخیص قطعات آن دشوار است. 
فضا چیزی است که اشیا را از هم جدا می‌کند.

نمی‌خواهید که فضای بیش از حد داشته باشید، زیرا در آن صورت دشوار است که بفهمید چیزها چگونه به هم مرتبط هستند. 
و نمی‌خواهید فضای بسیار کمی داشته باشید، زیرا در آن صورت تشخیص جدا بودن چیزها سخت می‌شود.

هیچ قانون سخت و سریعی در مورد اینکه کد دقیقاً چگونه باید فاصله‌گذاری شود وجود ندارد، جز اینکه باید به‌صورت یکدست انجام شود و فاصله‌ها باید به خواننده کمک کنند تا ساختار کد را بهتر درک کند.

> [!NOTE]
> **مثال: فاصله‌ها**
> 
> این کد به‌دلیل داشتن فضای بسیار کم، سخت خوانده می‌شود—اطلاعات بسیار کمی در مورد ساختار کد ارائه شده است:
> ```
> x=1+2;y=3+4;z=x+y;if(z>y+x){print"error";}
> ```
> اینجا همان بلوک کد با فضای بیش از حد است—فضا باعث می‌شود که خواننده نتواند ساختار کد را ببیند:
> ```
> x            =          1+        2;
> y = 3            +4;
> 
>   z = x    +      y;
> if (z  >     y+x)
>  {        print "error" ;
>         }
> ```
> این حتی از کد بدون فاصله سخت‌تر خوانده می‌شود.
> اینجا همان کد با فاصله‌گذاری منطقی است:
> ```
> x = 1 + 2;
> y = 3 + 4;
> z = x + y;
> if (z > y + x) {
>   print "error";
> }
> ```
> 
> این کد بسیار راحت‌تر خوانده می‌شود و به شما کمک می‌کند متوجه شوید که برنامه‌نویس چگونه قصد داشته برنامه را طراحی کند.
> سه متغیر تنظیم می‌شوند و سپس در شرایطی، یک خطا به کاربر نمایش داده می‌شود.
> این ساختار سیستم است که توسط نحوه استفاده برنامه‌نویس از فضا برای خواننده واضح شده است.
> قابل خواندن کردن کد به رفع آسان‌تر آن نیز کمک می‌کند.
> در مثال قبلی، وقتی کد به‌درستی فاصله‌گذاری می‌شود، به‌راحتی می‌توانیم ببینیم که `z` هرگز بزرگ‌تر از `y + x` نخواهد بود،
> زیرا `z` همیشه برابر با `y + x` است.
> بنابراین، بلوکی که با `if (z > y + x)` شروع می‌شود باید حذف شود، زیرا غیرضروری است.
> به‌طور کلی، اگر کدی بسیار پر از باگ دارید که خواندن آن نیز دشوار است، اولین کاری که باید انجام دهید این است که آن را خواناتر کنید.
> سپس می‌توانید با وضوح بیشتری ببینید که باگ‌ها کجا هستند.

### نام‌گذاری

بخش مهمی از خوانایی کد، انتخاب نام‌های خوب برای متغیرها، توابع، کلاس‌ها و غیره است. در حالت ایده‌آل:

**نام‌ها باید به‌اندازه کافی طولانی باشند تا کاملاً مشخص کنند که آن چیز چیست یا چه کاری انجام می‌دهد، ولی نه آن‌قدر طولانی که خواندن آن‌ها دشوار باشد.**

همچنین مهم است که به نحوه استفاده از تابع، متغیر و غیره فکر کنید. 
وقتی شروع به استفاده از نام آن‌ها در خطوط کد می‌کنید، آیا آن نام‌ها آن‌قدر طولانی خواهند بود که خواندن آن خطوط را دشوار کنند؟ 
برای مثال، اگر تابعی دارید که فقط یک‌بار، در یک خط به‌تنهایی فراخوانی می‌شود (بدون هیچ کد دیگری در آن خط)، می‌تواند نام نسبتاً بلندی داشته باشد. 
با این حال، تابعی که قرار است به‌طور مکرر در عبارات پیچیده استفاده شود، احتمالاً باید نام کوتاهی داشته باشد 
(البته هنوز باید به‌اندازه کافی طولانی باشد تا کاملاً مشخص کند چه کاری انجام می‌دهد).

> [!NOTE]
> **مثال: نام‌ها**
> در اینجا کدی با نام‌های بسیار بد آمده است:
> ```
> q = s(j, f, m);
> p(q);
> ```
> این نام‌ها بیان نمی‌کنند که متغیرها چه هستند یا توابع چه کاری انجام می‌دهند.
> در اینجا همان کد با نام‌های خوب آمده است:
> ```
> quarterly_total = sum(january, february, march);
> print(quarterly_total);
> ```
> 
> و در اینجا همان کد دوباره آمده است، با نام‌هایی که آن‌قدر طولانی هستند که خواندن آن‌ها دشوار است:
> ```
> quarterly_total_for_company_in_2011_as_of_today =
> add_all_of_these_together_and_return_the_result(january_total_amount,
> february_total_amount, march_total_amount);
> send_to_screen_and_dont_wait_for_user_to_respond(quarterly_total_for_company_in_2011_as_of_today);
> ```
> این نام‌ها فضای زیادی را اشغال می‌کنند، که باعث می‌شود خواندن آن‌ها دشوار شود.
> بنابراین، به‌نوعی نام‌گذاری چیزها نیز به این بازمی‌گردد که حروف و نمادها چگونه فضا را اشغال می‌کنند.

### توضیحات (کامنت‌ها)

داشتن توضیحات خوب در کد بخش مهمی از خوانا بودن آن است. 
با این حال، به‌طور کلی نباید توضیحاتی اضافه کنید که بگوید یک قطعه کد چه کاری انجام می‌دهد. 
این باید از خواندن کد واضح باشد. 
اگر واضح نیست، کد باید ساده‌تر شود. 
فقط اگر نمی‌توانید کد را ساده‌تر کنید، باید توضیحی بنویسید که توضیح دهد کد چه کاری انجام می‌دهد.

هدف واقعی توضیحات این است که توضیح دهند چرا کاری را انجام داده‌اید، زمانی که دلیل آن واضح نیست. 
اگر آن را توضیح ندهید، برنامه‌نویسان دیگر ممکن است گیج شوند و وقتی می‌خواهند کد شما را تغییر دهند، ممکن است بخش‌های مهمی از آن را حذف کنند اگر آن بخش‌ها به‌نظر نمی‌رسد دلیلی برای وجود داشته باشند.

برخی افراد معتقدند که خوانایی تمام و کمال سادگی کد است—اینکه اگر کد شما به‌راحتی خوانده شود، شما تمام کاری که باید به‌عنوان یک طراح انجام دهید را انجام داده‌اید. 
این درست نیست—شما می‌توانید کد بسیار خوانایی داشته باشید و همچنان سیستمی که بیش از حد پیچیده است. 
با این حال، خوانا کردن کد شما بسیار مهم است و معمولاً اولین قدمی است که باید در راه طراحی نرم‌افزار خوب برداشته شود.

## سادگی نیاز به طراحی دارد

متأسفانه، مردم به‌طور طبیعی سیستم‌های ساده نمی‌سازند. 
بدون توجه به طراحی، یک سیستم به‌مرور به یک هیولای بزرگ و پیچیده تبدیل می‌شود.

اگر پروژه شما طراحی خوبی نداشته باشد و همچنان رشد کند، در نهایت در پیچیدگی غرق خواهید شد. 
تصور این موضوع برای برخی افراد سخت است—برخی نمی‌توانند آینده‌ای فراتر از ناهار خود را تصور کنند و برخی دیگر تجربه کافی برای درک اینکه چقدر چیزها می‌توانند پیچیده شوند را ندارند. 
و ممکن است یک فرهنگ شرکتی وجود داشته باشد که بگوید، "ما فقط ویژگی‌های جدید را به‌سرعت سرهم می‌کنیم؛ قبول داریم که باید کارها را به روش درست انجام دهیم، اما نمی‌توانیم چون فلان و بهمان." 
اما یک روز، پروژه شما شکست خواهد خورد. 
و مهم نیست که چقدر دلایل برای آن شکست بیاورید، این واقعیت را تغییر نمی‌دهد که پروژه شما شکست خورده است.

از سوی دیگر، وقتی طراحی خوبی انجام داده‌اید، معمولاً خیلی اعتبار دریافت نمی‌کنید. 
شکست‌های فاجعه‌بار ناشی از طراحی نادرست بزرگ و قابل‌توجه هستند، درحالی‌که کارهای کوچک به‌سمت یک طراحی خوب برای افرادی که به‌طور دقیق با کد آشنا نیستند، نامرئی است. 
این می‌تواند شغل یک طراح را دشوار کند. 
رسیدگی کردن به‌ یک خرابی بزرگ تشکر زیادی برای شما به همراه خواهد داشت، اما جلوگیری از وقوع آن...خب، احتمالاً هیچ‌کس متوجه نخواهد شد.

بنابراین، بیایید همین‌جا به شما تبریک بگوییم. 
آیا کمی به طراحی فکر کردید؟ عالی! 
کاربران شما و توسعه‌دهندگان بعدی مزایای آن را خواهند دید—نرم‌افزار کاربردی، نسخه‌های به‌موقع و یک کد پایه واضح و قابل درک. 
شما به کار خود اطمینان خواهید داشت و با احساس موفقیت به خانه خواهید رفت. 
آیا سایر توسعه‌دهندگان خواهند دانست که چقدر کار برای اجرای بدون مشکل پروژه لازم بوده است؟ 
شاید نه. 
اما اشکالی ندارد. 
پاداش‌های دیگری هم در جهان وجود دارند که فراتر از تبریک همکاران شما هستند.

هرچند به‌ندرت، ممکن است برای همه کارهایی که انجام داده‌اید قدردانی شوید. 
ناامید نشوید—افراد در نهایت متوجه خواهد شد. و تا آن زمان، از تمام نتایج مثبت دیگر طراحی مؤثر و صحیح لذت ببرید.

> [!TIP]
> وقتی شروع به طراحی اصولی مانند آنچه در این کتاب آمده است در پروژه خود می‌کنید، ممکن است مدتی طول بکشد تا برخی از برنامه‌نویسان تازه‌کار یا همکاران شما بفهمند چرا آن‌ها نیز باید به‌خوبی طراحی کنند.
> خواندن این کتاب به آن‌ها کمک خواهد کرد.
> اگر نمی‌توانند یا نمی‌خواهند آن را بخوانند، به هدایت آن‌ها (یا در بدترین حالت مجبور کردنشان) به سمت تصمیمات طراحی خوب ادامه دهید، و پس از یکی دو سال (در بدترین حالت)، آن‌ها خواهند دید که تصمیمات طراحی خوب چقدر سودمند هستند.

